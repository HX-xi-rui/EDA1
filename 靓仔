// wire  CircuitCanvas Gate InputOutput 


// 逻辑门基类
class Gate : public CircuitElement {
public:
    // 构造函数，接收门类型和坐标位置
    Gate(ElementType type, int x, int y) : CircuitElement(type, x, y) {
        // 根据门类型创建输入输出引脚
        if (type == TYPE_NOT) {  // 如果是NOT门（单输入单输出）
            // 创建单个输入引脚（左侧）
            inputs.push_back(std::make_unique<Pin>(x - 20, y, true, this));
            // 创建单个输出引脚（右侧）
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
        else {  // 其他门类型（双输入单输出）
            // 创建第一个输入引脚（左上侧）
            inputs.push_back(std::make_unique<Pin>(x - 20, y - 10, true, this));
            // 创建第二个输入引脚（左下侧）
            inputs.push_back(std::make_unique<Pin>(x - 20, y + 10, true, this));
            // 创建输出引脚（右侧中间）
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
    }

    // 绘制门元件
    virtual void Draw(wxDC& dc) override {
        // 设置绘制颜色：选中时为红色，否则为黑色
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);  // 设置填充颜色为白色

        // 根据门类型绘制不同的图形
        switch (type) {
        case TYPE_AND:  // AND门
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);  // 绘制矩形
            dc.DrawText("AND", posX - 12, posY - 7);  // 绘制文本标签
            break;
        case TYPE_OR:   // OR门
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);  // 绘制圆角矩形
            dc.DrawText("OR", posX - 8, posY - 7);  // 绘制文本标签
            break;
        case TYPE_NOT:  // NOT门
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);  // 绘制矩形
            dc.DrawText("NOT", posX - 12, posY - 7);  // 绘制文本标签
            break;
        case TYPE_XOR:  // XOR门
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);  // 绘制圆角矩形
            dc.DrawText("XOR", posX - 12, posY - 7);  // 绘制文本标签
            break;
        case TYPE_NAND: // NAND门
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);  // 绘制矩形
            dc.DrawText("NAND", posX - 15, posY - 7);  // 绘制文本标签
            break;
        case TYPE_NOR:  // NOR门
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);  // 绘制圆角矩形
            dc.DrawText("NOR", posX - 12, posY - 7);  // 绘制文本标签
            break;
        default:
            break;  // 默认情况不处理
        }

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);  // 设置引脚颜色为黑色
        for (auto& pin : inputs) {  // 遍历所有输入引脚
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);  // 绘制圆形引脚
        }
        for (auto& pin : outputs) {  // 遍历所有输出引脚
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);  // 绘制圆形引脚
        }

        // 显示引脚值（在仿真时）
        if (wxWindow::FindWindowById(wxID_ANY)) {  // 检查是否有活动窗口
            dc.SetTextForeground(*wxBLUE);  // 设置文本颜色为蓝色
            wxFont smallFont = dc.GetFont();  // 获取当前字体
            smallFont.SetPointSize(8);  // 设置小字体大小
            dc.SetFont(smallFont);  // 应用小字体

            for (auto& pin : inputs) {  // 遍历输入引脚
                wxString val = pin->GetValue() ? "1" : "0";  // 获取引脚值并转换为字符串
                dc.DrawText(val, pin->GetX() - 8, pin->GetY() - 8);  // 在引脚旁绘制值
            }
            for (auto& pin : outputs) {  // 遍历输出引脚
                wxString val = pin->GetValue() ? "1" : "0";  // 获取引脚值并转换为字符串
                dc.DrawText(val, pin->GetX() + 5, pin->GetY() - 8);  // 在引脚旁绘制值
            }
        }
    }

    // 更新逻辑门状态
    virtual void Update() override {
        if (inputs.empty() || outputs.empty()) return;  // 检查引脚是否存在

        // 获取第一个输入引脚的值（如果已连接导线）
        bool val0 = inputs[0]->GetConnectedWire() ? inputs[0]->GetValue() : false;
        // 获取第二个输入引脚的值（如果存在且已连接导线）
        bool val1 = inputs.size() > 1 && inputs[1]->GetConnectedWire() ? inputs[1]->GetValue() : false;

        bool result = false;  // 初始化结果变量

        // 根据门类型计算输出结果
        switch (type) {
        case TYPE_AND:   // AND门：逻辑与
            result = val0 && val1;
            break;
        case TYPE_OR:    // OR门：逻辑或
            result = val0 || val1;
            break;
        case TYPE_NOT:   // NOT门：逻辑非
            result = !val0;
            break;
        case TYPE_XOR:   // XOR门：逻辑异或
            result = val0 != val1;
            break;
        case TYPE_NAND:  // NAND门：逻辑与非
            result = !(val0 && val1);
            break;
        case TYPE_NOR:   // NOR门：逻辑或非
            result = !(val0 || val1);
            break;
        default:
            break;  // 默认情况不处理
        }

        outputs[0]->SetValue(result);  // 将计算结果设置到输出引脚
    }

    // 获取所有引脚
    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> allPins;  // 创建引脚指针向量
        for (auto& pin : inputs) {  // 遍历输入引脚
            allPins.push_back(pin.get());  // 添加输入引脚指针
        }
        for (auto& pin : outputs) {  // 遍历输出引脚
            allPins.push_back(pin.get());  // 添加输出引脚指针
        }
        return allPins;  // 返回所有引脚
    }

    // 获取边界框
    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 20, 40, 40);  // 返回门的边界矩形
    }

    // 获取门名称
    virtual wxString GetName() const override {
        switch (type) {  // 根据类型返回对应名称
        case TYPE_AND: return "AND GATE";
        case TYPE_OR: return "OR GATE";
        case TYPE_NOT: return "NOT GATE";
        case TYPE_XOR: return "XOR GATE";
        case TYPE_NAND: return "NAND GATE";
        case TYPE_NOR: return "NOR GATE";
        default: return "Unknown";  // 未知类型
        }
    }

    // 获取显示名称
    virtual wxString GetDisplayName() const override {
        return GetName() + " Gate";  // 返回带"Gate"后缀的名称
    }

    // 序列化门数据
    virtual void Serialize(wxString& data) const override {
        // 只保存门的基本信息，不保存指针
        data += wxString::Format("%d,%d,%d", type, posX, posY);
    }

    // 反序列化门数据
    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");  // 创建字符串分词器
        if (tokenizer.CountTokens() >= 3) {  // 检查是否有足够的数据
            long typeVal, x, y;  // 定义变量存储解析结果
            tokenizer.GetNextToken().ToLong(&typeVal);  // 解析类型
            tokenizer.GetNextToken().ToLong(&x);  // 解析X坐标
            tokenizer.GetNextToken().ToLong(&y);  // 解析Y坐标
            SetPosition(x, y);  // 设置门的位置
        }
    }

    // 获取属性用于属性网格显示
    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));  // 添加类型属性
        pg->Append(new wxIntProperty("X Position", "X", posX));  // 添加X坐标属性
        pg->Append(new wxIntProperty("Y Position", "Y", posY));  // 添加Y坐标属性
    }

    // 从属性网格设置属性
    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");  // 获取X坐标值
        wxVariant yVar = pg->GetPropertyValue("Y");  // 获取Y坐标值
        if (xVar.IsType("long") && yVar.IsType("long")) {  // 检查类型是否正确
            SetPosition(xVar.GetLong(), yVar.GetLong());  // 设置新位置
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> inputs;  // 输入引脚容器
    std::vector<std::unique_ptr<Pin>> outputs; // 输出引脚容器
};

// 输入输出引脚类
class InputOutput : public CircuitElement {
public:
    // 构造函数，接收元件类型、坐标位置和自定义名称
    InputOutput(ElementType type, int x, int y, const wxString& name = "") : CircuitElement(type, x, y), value(false), customName(name) {  // 初始化基类和成员变量
        // 根据类型创建引脚：输入元件在右侧有输出引脚，输出元件在左侧有输入引脚
        if (type == TYPE_INPUT) {  // 如果是输入元件
            pins.push_back(std::make_unique<Pin>(x + 20, y, false, this)); // 创建输出引脚（右侧）
        }
        else {  // 如果是输出元件
            pins.push_back(std::make_unique<Pin>(x - 20, y, true, this)); // 创建输入引脚（左侧）
        }
    }

    // 绘制输入输出元件
    virtual void Draw(wxDC& dc) override {
        // 设置边框颜色：选中时为红色粗边框，否则为黑色细边框
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));

        // 根据元件类型和值设置填充颜色
        if (type == TYPE_INPUT) {  // 输入元件
            dc.SetBrush(value ? *wxGREEN_BRUSH : *wxYELLOW_BRUSH);  // 值为真时绿色，假时黄色
        }
        else {  // 输出元件
            dc.SetBrush(value ? *wxGREEN_BRUSH : *wxWHITE_BRUSH);  // 值为真时绿色，假时白色
        }

        dc.DrawRectangle(posX - 15, posY - 15, 30, 30);  // 绘制矩形元件

        // 显示标签文本
        wxString label;  // 定义标签变量
        if (!customName.empty()) {  // 如果有自定义名称
            label = customName;  // 使用自定义名称
        }
        else if (type == TYPE_INPUT) {  // 输入元件且无自定义名称
            label = "IN";  // 默认标签"IN"
        }
        else {  // 输出元件且无自定义名称
            label = "OUT";  // 默认标签"OUT"
        }
        // 根据标签长度调整水平位置，长文本左移更多
        dc.DrawText(label, posX - (label.Length() > 2 ? 12 : 7), posY - 7);

        // 显示当前值 - 使用更大的字体和更明显的颜色
        dc.SetTextForeground(value ? *wxRED : *wxBLUE);  // 值为真时红色，假时蓝色
        wxString valueText = value ? "1" : "0";  // 将布尔值转换为字符串
        wxFont valueFont = dc.GetFont();  // 获取当前字体
        valueFont.SetPointSize(10);  // 设置更大的字号
        valueFont.SetWeight(wxFONTWEIGHT_BOLD);  // 设置粗体
        dc.SetFont(valueFont);  // 应用新字体

        wxSize textSize = dc.GetTextExtent(valueText);  // 获取文本尺寸

        // 根据元件类型确定值文本的位置
        if (type == TYPE_INPUT) {  // 输入元件
            // 值显示在右侧内部
            dc.DrawText(valueText, posX + 15 - textSize.GetWidth() - 2, posY - textSize.GetHeight() / 2);
        }
        else {  // 输出元件
            // 值显示在左侧内部
            dc.DrawText(valueText, posX - 15 + 2, posY - textSize.GetHeight() / 2);
        }

        // 恢复默认字体
        valueFont.SetPointSize(8);  // 恢复较小字号
        valueFont.SetWeight(wxFONTWEIGHT_NORMAL);  // 恢复正常字重
        dc.SetFont(valueFont);  // 应用恢复后的字体

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);  // 设置引脚颜色为黑色
        dc.SetTextForeground(*wxBLACK);  // 恢复文本颜色为黑色
        for (auto& pin : pins) {  // 遍历所有引脚
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);  // 绘制圆形引脚
        }
    }

    // 更新元件状态
    virtual void Update() override {
        // 对于输入元件：把自身的value写到它的输出引脚（驱动信号）
        if (type == TYPE_INPUT) {
            if (!pins.empty()) {  // 确保有引脚
                // pins[0]是输出引脚（构造时如此）
                pins[0]->SetValue(value);  // 将输入元件的值设置到输出引脚
            }
        }
        // 对于输出元件：从连接的输入引脚读值到自身value（显示/记录输出）
        else if (type == TYPE_OUTPUT) {
            if (!pins.empty()) {  // 确保有引脚
                // pins[0]是输入引脚（构造时如此）
                value = pins[0]->GetValue();  // 从输入引脚读取值
            }
        }
    }

    // 设置元件值
    void SetValue(bool val) { value = val; }
    // 获取元件值
    bool GetValue() const { return value; }
    // 设置自定义名称
    void SetName(const wxString& name) { customName = name; }
    // 获取自定义名称
    wxString GetCustomName() const { return customName; }

    // 获取所有引脚指针
    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;  // 创建引脚指针向量
        for (auto& pin : pins) {  // 遍历引脚容器
            pinPtrs.push_back(pin.get());  // 添加原始指针
        }
        return pinPtrs;  // 返回引脚指针列表
    }

    // 获取边界框
    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 15, posY - 15, 30, 30);  // 返回元件边界矩形
    }

    // 获取元件类型名称
    virtual wxString GetName() const override {
        return type == TYPE_INPUT ? "INPUT" : "OUTPUT";  // 返回类型字符串
    }

    // 获取显示名称
    virtual wxString GetDisplayName() const override {
        if (!customName.empty()) {  // 如果有自定义名称
            return customName;  // 返回自定义名称
        }
        return type == TYPE_INPUT ? "Input Pin" : "Output Pin";  // 返回默认显示名称
    }

    // 序列化元件数据
    virtual void Serialize(wxString& data) const override {
        wxString nameToSave = customName;
        if (nameToSave.empty()) {
            nameToSave = type == TYPE_INPUT ? "INPUT" : "OUTPUT";
        }
        // 不保存指针信息
        data += wxString::Format("%d,%d,%d,%d,%s",
            type, posX, posY, value ? 1 : 0, nameToSave);
    }

    // 反序列化元件数据
    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");  // 创建字符串分词器
        if (tokenizer.CountTokens() >= 4) {  // 检查是否有足够的数据
            long typeVal, x, y, val;  // 定义解析变量
            tokenizer.GetNextToken().ToLong(&typeVal);  // 解析类型
            tokenizer.GetNextToken().ToLong(&x);  // 解析X坐标
            tokenizer.GetNextToken().ToLong(&y);  // 解析Y坐标
            tokenizer.GetNextToken().ToLong(&val);  // 解析值
            SetPosition(x, y);  // 设置位置
            value = val != 0;  // 设置布尔值

            if (tokenizer.HasMoreTokens()) {  // 如果还有更多数据
                customName = tokenizer.GetNextToken();  // 解析自定义名称
            }
        }
    }

    // 获取属性用于属性网格显示
    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));  // 类型属性
        pg->Append(new wxIntProperty("X Position", "X", posX));  // X坐标属性
        pg->Append(new wxIntProperty("Y Position", "Y", posY));  // Y坐标属性
        pg->Append(new wxStringProperty("Name", "Name", customName));  // 名称属性
        pg->Append(new wxBoolProperty("Value", "Value", value));  // 值属性
    }

    // 从属性网格设置属性
    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");  // 获取X坐标值
        wxVariant yVar = pg->GetPropertyValue("Y");  // 获取Y坐标值
        wxVariant nameVar = pg->GetPropertyValue("Name");  // 获取名称值
        wxVariant valueVar = pg->GetPropertyValue("Value");  // 获取布尔值

        if (xVar.IsType("long") && yVar.IsType("long")) {  // 检查坐标类型
            SetPosition(xVar.GetLong(), yVar.GetLong());  // 设置新位置
        }
        if (nameVar.IsType("string")) {  // 检查名称类型
            customName = nameVar.GetString();  // 设置新名称
        }
        if (valueVar.IsType("bool")) {  // 检查值类型
            value = valueVar.GetBool();  // 设置新值
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins; // 引脚列表（智能指针管理）
    bool value;  // 元件当前值
    wxString customName; // 自定义名称
};

// 导线类
class Wire {
public:
    // 构造函数，接收起始引脚和结束引脚
    Wire(Pin* start, Pin* end) : startPin(start), endPin(end) {
        // 建立双向连接：将导线对象设置到两个引脚中
        start->SetConnectedWire(this);
        end->SetConnectedWire(this);
    }

    // 绘制导线
    void Draw(wxDC& dc) {
        // 根据信号值选择颜色：绿色=1（高电平），红色=0（低电平）
        bool value = startPin->GetValue();  // 获取起始引脚的值
        dc.SetPen(value ? wxPen(*wxGREEN, 2) : wxPen(*wxRED, 2));  // 设置画笔颜色和宽度
        // 绘制从起始引脚到结束引脚的直线
        dc.DrawLine(startPin->GetX(), startPin->GetY(), endPin->GetX(), endPin->GetY());
    }

    // 更新导线状态 - 传递信号值
    void Update() {
        // 将起始引脚的值传递到结束引脚
        if (startPin && endPin) {  // 确保两个引脚都存在
            endPin->SetValue(startPin->GetValue());  // 传递信号值
        }
    }

    // 获取起始引脚
    Pin* GetStartPin() const { return startPin; }
    // 获取结束引脚
    Pin* GetEndPin() const { return endPin; }

    // 检查点是否在导线附近（用于选择导线）
    bool ContainsPoint(const wxPoint& point) const {
        if (!startPin || !endPin) return false;  // 如果引脚不存在返回false

        // 获取两个引脚的坐标
        int x1 = startPin->GetX(), y1 = startPin->GetY();
        int x2 = endPin->GetX(), y2 = endPin->GetY();

        // 计算点到线段的距离（使用向量投影方法）
        double A = point.x - x1;  // 点到起点向量的x分量
        double B = point.y - y1;  // 点到起点向量的y分量
        double C = x2 - x1;       // 线段向量的x分量
        double D = y2 - y1;       // 线段向量的y分量

        // 计算点在线段上的投影参数
        double dot = A * C + B * D;        // 点积
        double len_sq = C * C + D * D;     // 线段长度的平方
        double param = (len_sq != 0) ? dot / len_sq : -1;  // 投影参数，范围[0,1]表示在线段上

        double xx, yy;  // 在线段上最近点的坐标

        // 根据投影参数确定最近点
        if (param < 0) {        // 点在线段起点之前
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {   // 点在线段终点之后
            xx = x2;
            yy = y2;
        }
        else {                  // 点在线段上投影
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        // 计算点到最近点的距离
        double dx = point.x - xx;
        double dy = point.y - yy;
        // 如果距离小于5像素，则认为点在导线上
        return std::sqrt(dx * dx + dy * dy) < 5;
    }

    // 序列化导线数据
    void Serialize(wxString& data) const {
        if (startPin && endPin) {
            // 使用引脚坐标而不是指针，避免指针失效问题
            data += wxString::Format("WIRE,%d,%d,%d,%d,%d,%d",
                startPin->GetX(), startPin->GetY(), startPin->IsInput() ? 1 : 0,
                endPin->GetX(), endPin->GetY(), endPin->IsInput() ? 1 : 0);
        }
    }

private:
    Pin* startPin;  // 起始引脚指针
    Pin* endPin;    // 结束引脚指针
};

// 画布类 
class CircuitCanvas : public wxScrolledWindow {
public:
    // 构造函数
    CircuitCanvas(wxWindow* parent) : wxScrolledWindow(parent, wxID_ANY),
        currentTool(TYPE_SELECT), wiringMode(false), selectedElement(nullptr),
        startPin(nullptr), simulating(false), showGrid(true), zoomLevel(1.0),
        autoPlaceMode(false), autoPlaceType(TYPE_SELECT),
        virtualSize(2000, 2000), isRestoringState(false) {

        // 设置滚动条
        SetScrollRate(20, 20);  // 设置滚动步长
        SetVirtualSize(virtualSize);  // 设置虚拟大小

        // 设置双缓冲避免闪烁
        SetBackgroundStyle(wxBG_STYLE_PAINT);

        // 绑定各种事件处理函数
        Bind(wxEVT_PAINT, &CircuitCanvas::OnPaint, this);
        Bind(wxEVT_LEFT_DOWN, &CircuitCanvas::OnLeftDown, this);
        Bind(wxEVT_LEFT_UP, &CircuitCanvas::OnLeftUp, this);
        Bind(wxEVT_MOTION, &CircuitCanvas::OnMouseMove, this);
        Bind(wxEVT_RIGHT_DOWN, &CircuitCanvas::OnRightDown, this);
        Bind(wxEVT_MOUSEWHEEL, &CircuitCanvas::OnMouseWheel, this);
        Bind(wxEVT_KEY_DOWN, &CircuitCanvas::OnKeyDown, this);
        Bind(wxEVT_SIZE, &CircuitCanvas::OnSize, this);
        Bind(wxEVT_MENU, &CircuitCanvas::OnContextMenu, this);

        // 绑定滚动事件
        Bind(wxEVT_SCROLLWIN_THUMBTRACK, &CircuitCanvas::OnScroll, this);
        Bind(wxEVT_SCROLLWIN_THUMBRELEASE, &CircuitCanvas::OnScroll, this);

        SetFocus();  // 设置焦点以接收键盘事件
    }

    // 在指定位置创建元件，支持时序元件
    void CreateElementAtPosition(ElementType type, const wxPoint& pos) {
        std::unique_ptr<CircuitElement> newElement;

        if (type >= TYPE_AND && type <= TYPE_NOR) {  // 逻辑门元件
            newElement = std::make_unique<Gate>(type, pos.x, pos.y);
        }
        else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {  // 输入输出元件
            newElement = std::make_unique<InputOutput>(type, pos.x, pos.y);
        }
        else if (type == TYPE_CLOCK) {  // 时钟元件
            newElement = std::make_unique<ClockElement>(pos.x, pos.y);
        }
        else if (type == TYPE_D_FLIPFLOP) {  // D触发器
            newElement = std::make_unique<DFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_JK_FLIPFLOP) {  // JK触发器
            newElement = std::make_unique<JKFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_T_FLIPFLOP) {  // T触发器
            newElement = std::make_unique<TFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_REGISTER) {  // 寄存器
            newElement = std::make_unique<RegisterElement>(pos.x, pos.y);
        }

        if (newElement) {
            CircuitElement* elementPtr = newElement.get();
            elements.push_back(std::move(newElement));

            // 记录添加元件操作
            if (!isRestoringState) {
                wxString serializedData = SerializeElement(elementPtr);
                auto operation = std::make_unique<AddElementOperation>(serializedData);
                undoStack.push_back(std::move(operation));

                // 限制历史记录数量
                if (undoStack.size() > MAX_HISTORY) {
                    undoStack.erase(undoStack.begin());
                }

                redoStack.clear();
                UpdateUndoRedoStatus();
            }

            Refresh();
        }
    }

    // 设置自动放置模式
    void SetAutoPlaceMode(ElementType type) {
        autoPlaceMode = (type != TYPE_SELECT && type != TYPE_WIRE);  // 非选择和连线工具时启用
        autoPlaceType = type;  // 设置要自动放置的类型
        currentTool = type;    // 设置当前工具
        wiringMode = (type == TYPE_WIRE);  // 如果是连线工具则设置连线模式

        if (autoPlaceMode) {
            // 设置鼠标光标为十字准星
            SetCursor(wxCursor(wxCURSOR_CROSS));
            // 显示提示信息
            wxWindow* topWindow = wxGetTopLevelParent(this);
            if (topWindow) {
                wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
                if (statusBar) {
                    statusBar->SetStatusText("Click on canvas to place " + GetToolName(type));
                }
            }
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));  // 恢复正常光标
        }

        Refresh();  // 刷新显示
    }

    // 上下文菜单事件处理
    void OnContextMenu(wxCommandEvent& event) {
        switch (event.GetId()) {
        case wxID_DELETE:
            DeleteSelectedElement();  // 删除选中元件
            break;
        case wxID_PROPERTIES:
            // 属性菜单（暂未实现）
            break;
        default:
            break;
        }
    }

    // 设置当前工具
    void SetCurrentTool(ElementType tool) {
        currentTool = tool;
        wiringMode = (tool == TYPE_WIRE);  // 设置连线模式
        autoPlaceMode = false; // 重置自动放置模式

        if (!wiringMode) {
            startPin = nullptr;  // 清除连线起始引脚
        }

        // 设置合适的鼠标光标
        if (tool == TYPE_TOGGLE_VALUE) {
            SetCursor(wxCursor(wxCURSOR_HAND));  // 切换值工具使用手型光标
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));  // 其他工具使用箭头光标
        }
        Refresh();  // 刷新显示
    }

    // 删除选中元件
    void DeleteSelectedElement() {
        if (selectedElement && !isRestoringState) {
            wxMessageDialog dialog(GetParent(),
                "Are you sure you want to delete the selected element?",
                "Confirm Delete",
                wxYES_NO | wxICON_QUESTION);

            if (dialog.ShowModal() == wxID_YES) {
                // 序列化元件数据
                wxString serializedData = SerializeElement(selectedElement);

                // 找到要删除的元件
                std::unique_ptr<CircuitElement> elementToDelete;
                auto it = std::find_if(elements.begin(), elements.end(),
                    [this](const std::unique_ptr<CircuitElement>& elem) {
                        return elem.get() == selectedElement;
                    });

                if (it != elements.end()) {
                    elementToDelete = std::move(*it);

                    // 先记录删除操作
                    auto operation = std::make_unique<DeleteElementOperation>(
                        std::move(elementToDelete), serializedData);
                    undoStack.push_back(std::move(operation));

                    // 限制历史记录数量
                    if (undoStack.size() > MAX_HISTORY) {
                        undoStack.erase(undoStack.begin());
                    }

                    redoStack.clear();
                    UpdateUndoRedoStatus();

                    // 然后实际删除
                    RemoveElementWithoutHistory(selectedElement);
                }

                selectedElement = nullptr;
                Refresh();
            }
        }
    }

    // 开始仿真
    void StartSimulation() {
        simulating = true;
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 1);

        // 为所有输入元件随机设置初始值
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* io = dynamic_cast<InputOutput*>(element.get());
                if (io) {
                    io->SetValue(dis(gen) == 0);  // 随机设置0或1
                }
            }
        }
        UpdateCircuit();  // 更新电路状态
        Refresh();  // 刷新显示
    }

    // 获取元件列表
    const std::vector<std::unique_ptr<CircuitElement>>& GetElements() const {
        return elements;
    }

    // 获取导线列表
    const std::vector<std::unique_ptr<Wire>>& GetWires() const {
        return wires;
    }

    // 停止仿真
    void StopSimulation() {
        simulating = false;

        // 将所有输入元件的值设为0（false）
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                if (input) {
                    input->SetValue(false);  // 重置为0
                }
            }
        }

        // 更新电路状态以反映所有输入为0的情况
        UpdateCircuit();
        Refresh();  // 刷新显示
    }

    // 更新整个电路状态
    void UpdateCircuit() {
        // 多次迭代确保信号稳定传播
        for (int i = 0; i < 5; ++i) {
            // 先更新输入元件
            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    element->Update();
                }
            }

            // 更新导线传递信号
            for (auto& wire : wires) {
                wire->Update();
            }

            // 更新逻辑门元件
            for (auto& element : elements) {
                if (element->GetType() >= TYPE_AND && element->GetType() <= TYPE_NOR) {
                    element->Update();
                }
            }

            // 再次更新导线
            for (auto& wire : wires) {
                wire->Update();
            }

            // 更新输出元件
            for (auto& element : elements) {
                if (element->GetType() == TYPE_OUTPUT) {
                    element->Update();
                }
            }
        }
    }

    // 清空画布
    void Clear() {
        elements.clear();  // 清空元件
        wires.clear();     // 清空导线
        selectedElement = nullptr;  // 清除选中
        startPin = nullptr;         // 清除连线起始引脚
        autoPlaceMode = false;      // 关闭自动放置模式
        undoStack.clear();          // 清空撤销栈
        redoStack.clear();          // 清空重做栈
        Refresh();  // 刷新显示
    }

    //保存电路图
    bool SaveCircuit(const wxString& filename) {
        wxFile file;
        if (file.Create(filename, true)) {
            wxString data;

            // 保存所有元件
            for (auto& element : elements) {
                element->Serialize(data);
                data += "\n";
            }

            // 保存所有导线 
            for (auto& wire : wires) {
                Pin* startPin = wire->GetStartPin();
                Pin* endPin = wire->GetEndPin();

                if (startPin && endPin) {
                    // 保存起始引脚和结束引脚的坐标
                    data += wxString::Format("WIRE,%d,%d,%d,%d\n",
                        startPin->GetX(), startPin->GetY(),
                        endPin->GetX(), endPin->GetY());
                }
            }

            file.Write(data);
            file.Close();
            return true;
        }
        return false;
    }

    //加载电路图
    bool LoadCircuit(const wxString& filename) {
        wxFile file;
        if (file.Open(filename)) {
            wxString data;
            file.ReadAll(&data);
            file.Close();

            Clear();

            // 第一遍：加载所有元件
            wxStringTokenizer lines(data, "\n");
            while (lines.HasMoreTokens()) {
                wxString line = lines.GetNextToken().Trim();
                if (line.empty()) continue;

                wxStringTokenizer tokens(line, ",");
                if (tokens.HasMoreTokens()) {
                    wxString firstToken = tokens.GetNextToken();

                    if (firstToken == "WIRE") {
                        // 导线在第二遍处理
                        continue;
                    }
                    else {
                        long typeVal;
                        if (firstToken.ToLong(&typeVal)) {
                            ElementType type = static_cast<ElementType>(typeVal);

                            if (type >= TYPE_AND && type <= TYPE_NOR) {
                                auto gate = std::make_unique<Gate>(type, 0, 0);
                                gate->Deserialize(line);
                                elements.push_back(std::move(gate));
                            }
                            else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
                                auto io = std::make_unique<InputOutput>(type, 0, 0);
                                io->Deserialize(line);
                                elements.push_back(std::move(io));
                            }
                        }
                    }
                }
            }

            // 第二遍：重建导线连接
            lines = wxStringTokenizer(data, "\n");
            while (lines.HasMoreTokens()) {
                wxString line = lines.GetNextToken().Trim();
                if (line.empty()) continue;

                wxStringTokenizer tokens(line, ",");
                if (tokens.HasMoreTokens()) {
                    wxString firstToken = tokens.GetNextToken();

                    if (firstToken == "WIRE") {
                        if (tokens.CountTokens() >= 4) {
                            long startX, startY, endX, endY;
                            tokens.GetNextToken().ToLong(&startX);
                            tokens.GetNextToken().ToLong(&startY);
                            tokens.GetNextToken().ToLong(&endX);
                            tokens.GetNextToken().ToLong(&endY);

                            // 通过坐标查找对应的引脚
                            Pin* startPin = FindPinByPosition(startX, startY);
                            Pin* endPin = FindPinByPosition(endX, endY);

                            if (startPin && endPin && startPin->IsInput() != endPin->IsInput()) {
                                // 确保连接方向正确：输出引脚 -> 输入引脚
                                if (!startPin->IsInput() && endPin->IsInput()) {
                                    wires.push_back(std::make_unique<Wire>(startPin, endPin));
                                }
                                else if (startPin->IsInput() && !endPin->IsInput()) {
                                    wires.push_back(std::make_unique<Wire>(endPin, startPin));
                                }
                            }
                        }
                    }
                }
            }

            UpdateCircuit();
            Refresh();
            return true;
        }
        return false;
    }

    // 切换网格显示
    void ToggleGrid() {
        showGrid = !showGrid;
        Refresh();  // 刷新显示
    }

    // 删除所有元件
    void DeleteAll() {
        if (wxMessageBox("Are you sure you want to delete all elements?", "Confirm Delete All",
            wxYES_NO | wxICON_QUESTION, GetParent()) == wxYES) {
            Clear();
        }
    }

    // 放大
    void ZoomIn() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel *= 1.2;  // 增加缩放级别
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 缩小
    void ZoomOut() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel /= 1.2;  // 减小缩放级别
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 重置缩放
    void ResetZoom() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel = 1.0;  // 恢复原始缩放
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 获取缩放级别
    double GetZoomLevel() const { return zoomLevel; }

    // 获取选中元件
    CircuitElement* GetSelectedElement() const { return selectedElement; }

    // 重命名选中元件
    void RenameSelectedElement(const wxString& newName) {
        if (selectedElement) {
            InputOutput* io = dynamic_cast<InputOutput*>(selectedElement);
            if (io) {
                io->SetName(newName);  // 设置新名称
                Refresh();  // 刷新显示
            }
        }
    }

    // 显示真值表
    void ShowTruthTable();

    // 获取所有输入引脚
    std::vector<InputOutput*> GetInputPins() const {
        std::vector<InputOutput*> inputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                inputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return inputs;
    }

    // 获取所有输出引脚
    std::vector<InputOutput*> GetOutputPins() const {
        std::vector<InputOutput*> outputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_OUTPUT) {
                outputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return outputs;
    }

    // 公共撤销/重做接口
    bool CanUndo() const { return !undoStack.empty(); }
    bool CanRedo() const { return !redoStack.empty(); }

    void Undo() {
        if (!CanUndo() || isRestoringState) return;

        isRestoringState = true;

        // 执行撤销操作
        if (!undoStack.empty()) {
            auto& operation = undoStack.back();
            operation->Undo(this);

            // 移动到重做栈
            redoStack.push_back(std::move(operation));
            undoStack.pop_back();
        }

        isRestoringState = false;
        UpdateUndoRedoStatus();
        Refresh();

        // 更新状态栏
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow) {
            wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
            if (statusBar) {
                statusBar->SetStatusText("Undo performed");
            }
        }
    }

    void Redo() {
        if (!CanRedo() || isRestoringState) return;

        isRestoringState = true;

        // 执行重做操作
        if (!redoStack.empty()) {
            auto& operation = redoStack.back();
            operation->Execute(this);

            // 移动回撤销栈
            undoStack.push_back(std::move(operation));
            redoStack.pop_back();
        }

        isRestoringState = false;
        UpdateUndoRedoStatus();
        Refresh();

        // 更新状态栏
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow) {
            wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
            if (statusBar) {
                statusBar->SetStatusText("Redo performed");
            }
        }
    }

    void ClearHistory() {
        undoStack.clear();
        redoStack.clear();
        UpdateUndoRedoStatus();
    }

    // 检查是否在自动放置模式
    bool IsInAutoPlaceMode() const { return autoPlaceMode; }
    // 获取自动放置类型
    ElementType GetAutoPlaceType() const { return autoPlaceType; }

private:
    // === 操作系统 ===
    enum OperationType {
        OP_ADD_ELEMENT,
        OP_DELETE_ELEMENT,
        OP_ADD_WIRE,
        OP_DELETE_WIRE,
        OP_MOVE_ELEMENT,
        OP_CHANGE_VALUE
    };

    class Operation {
    public:
        Operation(OperationType type) : type(type) {}
        virtual ~Operation() {}
        virtual void Execute(CircuitCanvas* canvas) = 0;
        virtual void Undo(CircuitCanvas* canvas) = 0;
        OperationType GetType() const { return type; }
    private:
        OperationType type;
    };

    class AddElementOperation : public Operation {
    public:
        AddElementOperation(const wxString& serializedData)
            : Operation(OP_ADD_ELEMENT), serializedData(serializedData) {}

        virtual void Execute(CircuitCanvas* canvas) override {
            canvas->RestoreElementFromSerializedData(serializedData);
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 找到并删除最后添加的元件（就是我们刚刚重做添加的那个）
            if (!canvas->elements.empty()) {
                CircuitElement* elementToRemove = canvas->elements.back().get();
                canvas->RemoveElementWithoutHistory(elementToRemove);
            }
        }

    private:
        wxString serializedData;
    };

    class AddWireOperation : public Operation {
    public:
        AddWireOperation(const wxString& serializedData)
            : Operation(OP_ADD_WIRE), serializedData(serializedData) {}

        virtual void Execute(CircuitCanvas* canvas) override {
            canvas->RestoreWireFromSerializedData(serializedData);
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 找到并删除最后添加的导线
            if (!canvas->wires.empty()) {
                Wire* wireToRemove = canvas->wires.back().get();
                canvas->RemoveWireWithoutHistory(wireToRemove);
            }
        }

    private:
        wxString serializedData;
    };

    class DeleteElementOperation : public Operation {
    public:
        DeleteElementOperation(std::unique_ptr<CircuitElement> element, const wxString& serializedData)
            : Operation(OP_DELETE_ELEMENT), element(std::move(element)), serializedData(serializedData) {}

        virtual void Execute(CircuitCanvas* canvas) override {
            // 重做删除操作：再次删除
            if (element) {
                canvas->RemoveElementWithoutHistory(element.get());
            }
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 撤销删除操作：恢复元件
            canvas->RestoreElementFromSerializedData(serializedData);
        }

    private:
        std::unique_ptr<CircuitElement> element;
        wxString serializedData;
    };

    class DeleteWireOperation : public Operation {
    public:
        DeleteWireOperation(std::unique_ptr<Wire> wire, const wxString& serializedData)
            : Operation(OP_DELETE_WIRE), wire(std::move(wire)), serializedData(serializedData) {}

        virtual void Execute(CircuitCanvas* canvas) override {
            // 重做删除操作：再次删除
            if (wire) {
                canvas->RemoveWireWithoutHistory(wire.get());
            }
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 撤销删除操作：恢复导线
            canvas->RestoreWireFromSerializedData(serializedData);
        }

    private:
        std::unique_ptr<Wire> wire;
        wxString serializedData;
    };

    // === 撤销/重做系统 ===
    std::vector<std::unique_ptr<Operation>> undoStack;
    std::vector<std::unique_ptr<Operation>> redoStack;
    const int MAX_HISTORY = 50;
    bool isRestoringState;

    // === 序列化和反序列化方法 ===
    wxString SerializeElement(CircuitElement* element) {
        wxString data;
        element->Serialize(data);
        return data;
    }

    wxString SerializeWire(Wire* wire) {
        wxString data;
        wire->Serialize(data);
        return data;
    }

    void RestoreElementFromSerializedData(const wxString& data) {
        CreateElementFromSerializedData(data);
        UpdateCircuit();
        Refresh();
    }

    void RestoreWireFromSerializedData(const wxString& data) {
        CreateWireFromSerializedData(data);
        UpdateCircuit();
        Refresh();
    }

    void RemoveElementWithoutHistory(CircuitElement* element) {
        isRestoringState = true;

        // 删除与元件引脚相连的所有导线
        auto pins = element->GetPins();
        for (auto& pin : pins) {
            for (auto wireIt = wires.begin(); wireIt != wires.end(); ) {
                if ((*wireIt)->GetStartPin() == pin || (*wireIt)->GetEndPin() == pin) {
                    wireIt = wires.erase(wireIt);
                }
                else {
                    ++wireIt;
                }
            }
        }

        // 删除元件
        auto it = std::find_if(elements.begin(), elements.end(),
            [element](const std::unique_ptr<CircuitElement>& elem) {
                return elem.get() == element;
            });

        if (it != elements.end()) {
            elements.erase(it);
        }

        if (selectedElement == element) {
            selectedElement = nullptr;
        }

        isRestoringState = false;
        UpdateCircuit();
        Refresh();
    }

    void RemoveWireWithoutHistory(Wire* wire) {
        isRestoringState = true;

        auto it = std::find_if(wires.begin(), wires.end(),
            [wire](const std::unique_ptr<Wire>& w) {
                return w.get() == wire;
            });

        if (it != wires.end()) {
            wires.erase(it);
        }

        isRestoringState = false;
        UpdateCircuit();
        Refresh();
    }

    void CompleteWireConnection(Pin* startPin, Pin* endPin) {
        if (startPin && endPin && startPin->IsInput() != endPin->IsInput()) {
            Pin* outputPin = startPin->IsInput() ? endPin : startPin;
            Pin* inputPin = startPin->IsInput() ? startPin : endPin;

            // 创建导线
            wires.push_back(std::make_unique<Wire>(outputPin, inputPin));
            Wire* wirePtr = wires.back().get();

            // 记录添加导线操作
            if (!isRestoringState) {
                wxString serializedData = SerializeWire(wirePtr);
                auto operation = std::make_unique<AddWireOperation>(serializedData);
                undoStack.push_back(std::move(operation));

                // 限制历史记录数量
                if (undoStack.size() > MAX_HISTORY) {
                    undoStack.erase(undoStack.begin());
                }

                redoStack.clear();
                UpdateUndoRedoStatus();
            }

            UpdateCircuit();
        }
        this->startPin = nullptr;
    }

    // === 原有的私有方法 ===
    // 从序列化数据创建元件
    void CreateElementFromSerializedData(const wxString& data) {
        wxStringTokenizer tokens(data, ",");
        if (tokens.CountTokens() >= 3) {
            long typeVal, x, y;
            tokens.GetNextToken().ToLong(&typeVal);
            tokens.GetNextToken().ToLong(&x);
            tokens.GetNextToken().ToLong(&y);

            ElementType type = static_cast<ElementType>(typeVal);
            std::unique_ptr<CircuitElement> newElement;

            if (type >= TYPE_AND && type <= TYPE_NOR) {
                newElement = std::make_unique<Gate>(type, x, y);
            }
            else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
                newElement = std::make_unique<InputOutput>(type, x, y);

                // 处理输入输出的额外属性
                if (tokens.HasMoreTokens()) {
                    long value;
                    tokens.GetNextToken().ToLong(&value);
                    if (InputOutput* io = dynamic_cast<InputOutput*>(newElement.get())) {
                        io->SetValue(value != 0);
                    }
                    if (tokens.HasMoreTokens()) {
                        wxString name = tokens.GetNextToken();
                        if (InputOutput* io = dynamic_cast<InputOutput*>(newElement.get())) {
                            io->SetName(name);
                        }
                    }
                }
            }
            else if (type == TYPE_CLOCK) {
                newElement = std::make_unique<ClockElement>(x, y);
                if (tokens.HasMoreTokens()) {
                    long freq;
                    tokens.GetNextToken().ToLong(&freq);
                    if (ClockElement* clock = dynamic_cast<ClockElement*>(newElement.get())) {
                        clock->SetFrequency(freq);
                    }
                }
            }
            else if (type == TYPE_D_FLIPFLOP) {
                newElement = std::make_unique<DFlipFlop>(x, y);
            }
            else if (type == TYPE_JK_FLIPFLOP) {
                newElement = std::make_unique<JKFlipFlop>(x, y);
            }
            else if (type == TYPE_T_FLIPFLOP) {
                newElement = std::make_unique<TFlipFlop>(x, y);
            }
            else if (type == TYPE_REGISTER) {
                newElement = std::make_unique<RegisterElement>(x, y);
            }

            if (newElement) {
                elements.push_back(std::move(newElement));
            }
        }
    }

    // 从序列化数据创建导线
    void CreateWireFromSerializedData(const wxString& data) {
        wxStringTokenizer tokens(data, ",");
        tokens.GetNextToken(); // 跳过 "WIRE"

        if (tokens.CountTokens() >= 6) {
            long startX, startY, startIsInput, endX, endY, endIsInput;
            tokens.GetNextToken().ToLong(&startX);
            tokens.GetNextToken().ToLong(&startY);
            tokens.GetNextToken().ToLong(&startIsInput);
            tokens.GetNextToken().ToLong(&endX);
            tokens.GetNextToken().ToLong(&endY);
            tokens.GetNextToken().ToLong(&endIsInput);

            // 通过坐标查找对应的引脚
            Pin* startPin = FindPinByPosition(startX, startY);
            Pin* endPin = FindPinByPosition(endX, endY);

            // 验证引脚类型匹配
            if (startPin && endPin &&
                startPin->IsInput() == (startIsInput == 1) &&
                endPin->IsInput() == (endIsInput == 1)) {

                // 确保连接方向正确：输出引脚 -> 输入引脚
                if (!startPin->IsInput() && endPin->IsInput()) {
                    wires.push_back(std::make_unique<Wire>(startPin, endPin));
                }
                else if (startPin->IsInput() && !endPin->IsInput()) {
                    wires.push_back(std::make_unique<Wire>(endPin, startPin));
                }
            }
        }
    }

    // 通过坐标查找引脚
    Pin* FindPinByPosition(int x, int y) {
        const int tolerance = 5;
        for (auto& element : elements) {
            for (auto pin : element->GetPins()) {
                int pinX = pin->GetX();
                int pinY = pin->GetY();
                if (abs(pinX - x) <= tolerance && abs(pinY - y) <= tolerance) {
                    return pin;
                }
            }
        }
        return nullptr;
    }

    // 更新撤销/重做按钮状态
    void UpdateUndoRedoStatus() {
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
            wxFrame* frame = static_cast<wxFrame*>(topWindow);
            if (wxMenuBar* menuBar = frame->GetMenuBar()) {
                menuBar->Enable(wxID_UNDO, CanUndo());
                menuBar->Enable(wxID_REDO, CanRedo());
            }
            if (wxToolBar* toolBar = frame->GetToolBar()) {
                toolBar->EnableTool(wxID_UNDO, CanUndo());
                toolBar->EnableTool(wxID_REDO, CanRedo());
            }
        }
    }

    // 原有的私有成员变量
    ElementType currentTool;
    bool wiringMode;
    bool simulating;
    bool showGrid;
    double zoomLevel;
    CircuitElement* selectedElement;
    Pin* startPin;
    wxPoint lastMousePos;
    wxPoint dragStartPos;
    wxPoint elementStartPos;
    bool autoPlaceMode;
    ElementType autoPlaceType;
    wxSize virtualSize;
    std::vector<std::unique_ptr<CircuitElement>> elements;
    std::vector<std::unique_ptr<Wire>> wires;

    // 绘制事件处理
    void OnPaint(wxPaintEvent& event) {
        wxAutoBufferedPaintDC dc(this);  // 创建双缓冲绘图设备上下文
        DoPrepareDC(dc);  // 准备设备上下文，处理滚动和缩放

        dc.Clear();  // 清空画布

        dc.SetUserScale(zoomLevel, zoomLevel);  // 应用缩放

        // 获取可见区域（虚拟坐标）
        int vx, vy;
        GetViewStart(&vx, &vy);
        vx *= 10; vy *= 10;  // 转换为虚拟坐标

        wxSize clientSize = GetClientSize();
        int startX = vx;
        int startY = vy;
        int endX = vx + clientSize.x / zoomLevel;
        int endY = vy + clientSize.y / zoomLevel;

        // 绘制网格（只在可见区域绘制以提高性能）
        if (showGrid) {
            dc.SetPen(wxPen(wxColour(220, 220, 220), 1));

            // 计算网格起始位置（对齐到网格）
            int gridStartX = (startX / 20) * 20;
            int gridStartY = (startY / 20) * 20;

            // 绘制垂直线
            for (int x = gridStartX; x <= endX; x += 20) {
                dc.DrawLine(x, startY, x, endY);
            }
            // 绘制水平线
            for (int y = gridStartY; y <= endY; y += 20) {
                dc.DrawLine(startX, y, endX, y);
            }
        }

        // 绘制所有导线
        for (auto& wire : wires) {
            wire->Draw(dc);
        }

        // 绘制所有元件（只绘制在可见区域内的元件以提高性能）
        for (auto& element : elements) {
            wxRect bbox = element->GetBoundingBox();
            // 简单的可见性检查
            if (bbox.GetRight() >= startX && bbox.GetLeft() <= endX &&
                bbox.GetBottom() >= startY && bbox.GetTop() <= endY) {
                element->Draw(dc);
            }
        }

        // 为输入元件添加点击提示
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxFont smallFont = dc.GetFont();
            smallFont.SetPointSize(7);
            dc.SetFont(smallFont);

            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                    if (input) {
                        wxRect bbox = element->GetBoundingBox();
                        // 可见性检查
                        if (bbox.GetRight() >= startX && bbox.GetLeft() <= endX &&
                            bbox.GetBottom() >= startY && bbox.GetTop() <= endY) {
                            wxString hint = "(Click to toggle)";
                            wxSize textSize = dc.GetTextExtent(hint);
                            dc.DrawText(hint,
                                bbox.GetLeft() + (bbox.GetWidth() - textSize.GetWidth()) / 2,
                                bbox.GetBottom() + 5);
                        }
                    }
                }
            }
        }

        // 绘制连线过程中的临时线
        if (wiringMode && startPin) {
            dc.SetPen(wxPen(*wxBLUE, 2, wxPENSTYLE_DOT));
            dc.DrawLine(startPin->GetX(), startPin->GetY(), lastMousePos.x, lastMousePos.y);
        }

        // 绘制自动放置预览
        if (autoPlaceMode && !simulating) {
            DrawAutoPlacePreview(dc, lastMousePos);
        }

        dc.SetUserScale(1.0, 1.0);  // 恢复原始缩放

        // 绘制状态信息
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxString toolText = GetToolName(currentTool);
            if (autoPlaceMode) {
                toolText += " - Click to place";
            }
            dc.DrawText(toolText, 10, 10);

            // 显示当前视图位置和缩放信息
            wxString viewInfo = wxString::Format("View: (%d,%d) Zoom: %.0f%%", vx, vy, zoomLevel * 100);
            dc.DrawText(viewInfo, 10, 30);
        }
        else {
            dc.SetTextForeground(*wxRED);
            dc.DrawText("SIMULATION RUNNING", 10, 10);
        }
    }

    // 绘制自动放置预览
    void DrawAutoPlacePreview(wxDC& dc, const wxPoint& pos) {
        dc.SetPen(wxPen(*wxLIGHT_GREY, 1, wxPENSTYLE_DOT));  // 浅灰色虚线
        dc.SetBrush(*wxTRANSPARENT_BRUSH);  // 透明填充

        // 根据元件类型绘制预览轮廓
        switch (autoPlaceType) {
        case TYPE_AND:
        case TYPE_OR:
        case TYPE_NOT:
        case TYPE_XOR:
        case TYPE_NAND:
        case TYPE_NOR:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);  // 矩形轮廓
            break;
        case TYPE_INPUT:
        case TYPE_OUTPUT:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);  // 矩形轮廓
            break;
        default:
            break;
        }
    }

    // 鼠标左键按下事件
    void OnLeftDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;  // 调整到缩放后坐标
        pos.y /= zoomLevel;
        lastMousePos = pos;  // 记录鼠标位置

        // 如果是显示真值工具模式，优先处理输入元件点击
        if (currentTool == TYPE_TOGGLE_VALUE) {
            if (TryToggleInputElement(pos)) {
                Refresh();
                return;
            }
        }

        if (autoPlaceMode) {
            // 自动放置模式：直接创建元件
            CreateElementAtPosition(autoPlaceType, pos);
            return;
        }

        if (currentTool == TYPE_SELECT || currentTool == TYPE_TOGGLE_VALUE) {
            selectedElement = nullptr;
            // 从后向前遍历（处理重叠元件）
            for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
                if ((*it)->GetBoundingBox().Contains(pos)) {
                    selectedElement = it->get();
                    (*it)->SetSelected(true);

                    // 只有在选择工具模式下才能拖动
                    if (currentTool == TYPE_SELECT) {
                        dragStartPos = pos;  // 记录拖动起始位置
                        elementStartPos = wxPoint((*it)->GetX(), (*it)->GetY());  // 记录元件起始位置
                    }
                    break;
                }
            }

            // 如果没有选中元件，清除所有选中状态
            if (selectedElement == nullptr) {
                for (auto& element : elements) {
                    element->SetSelected(false);
                }
            }
        }
        // 在 OnLeftDown 方法中找到这个部分：
        else if (wiringMode) {
            // 连线模式：处理引脚连接
            Pin* pin = FindPinAt(pos);
            if (pin) {
                if (startPin == nullptr) {
                    startPin = pin;  // 设置起始引脚
                }
                else if (pin != startPin) {
                    // 确保连接的是输入和输出引脚
                    if (startPin->IsInput() != pin->IsInput()) {
                        // 使用新的方法完成连线并记录操作
                        CompleteWireConnection(startPin, pin);
                    }
                    startPin = nullptr;  // 重置起始引脚
                }
            }
            else if (startPin != nullptr) {
                startPin = nullptr;  // 点击空白处重置起始引脚
            }
        }
        else {
            // 传统模式：点击创建元件
            CreateElementAtPosition(currentTool, pos);
        }

        Refresh();  // 刷新显示
    }

    // 尝试切换输入元件的值
    bool TryToggleInputElement(const wxPoint& pos) {
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT && element->GetBoundingBox().Contains(pos)) {
                InputOutput* inputElement = dynamic_cast<InputOutput*>(element.get());
                if (inputElement) {
                    // 切换输入值（0变1，1变0）
                    inputElement->SetValue(!inputElement->GetValue());

                    // 更新电路状态
                    UpdateCircuit();

                    // 更新状态栏
                    wxWindow* topWindow = wxGetTopLevelParent(this);
                    if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
                        wxFrame* frame = static_cast<wxFrame*>(topWindow);
                        wxStatusBar* statusBar = frame->GetStatusBar();
                        if (statusBar) {
                            wxString state = inputElement->GetValue() ? "1" : "0";
                            wxString name = inputElement->GetDisplayName();
                            statusBar->SetStatusText(wxString::Format("%s toggled to %s", name, state));
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }

    // 鼠标左键释放事件
    void OnLeftUp(wxMouseEvent& event) {
        if (selectedElement) {
            selectedElement->SetSelected(false);  // 取消选中状态
        }
    }

    // 鼠标移动事件
    void OnMouseMove(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;
        pos.y /= zoomLevel;
        lastMousePos = pos;  // 记录鼠标位置

        // 只有在选择工具模式下才能拖动元件
        if (event.Dragging() && selectedElement && currentTool == TYPE_SELECT) {
            int gridSize = 20;  // 网格大小
            // 计算新位置
            int x = elementStartPos.x + (pos.x - dragStartPos.x);
            int y = elementStartPos.y + (pos.y - dragStartPos.y);

            // 对齐到网格
            x = (x / gridSize) * gridSize;
            y = (y / gridSize) * gridSize;

            selectedElement->SetPosition(x, y);  // 设置新位置
            Refresh();  // 刷新显示
        }

        // 连线模式下刷新临时线显示
        if (wiringMode && startPin) {
            Refresh();
        }

        // 在自动放置模式下实时刷新预览
        if (autoPlaceMode) {
            Refresh();
        }

        // 更新状态栏显示位置信息
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
            wxFrame* frame = static_cast<wxFrame*>(topWindow);
            wxStatusBar* statusBar = frame->GetStatusBar();
            if (statusBar) {
                int vx, vy;
                GetViewStart(&vx, &vy);
                wxString posInfo = wxString::Format("Position: (%d,%d)  View: (%d,%d)",
                    lastMousePos.x, lastMousePos.y, vx * 10, vy * 10);
                statusBar->SetStatusText(posInfo, 1);  // 在第二个字段显示
            }
        }
    }

    // 鼠标右键按下事件
    void OnRightDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;
        pos.y /= zoomLevel;

        CircuitElement* clickedElement = nullptr;
        // 查找点击的元件
        for (auto& element : elements) {
            if (element->GetBoundingBox().Contains(pos)) {
                clickedElement = element.get();
                break;
            }
        }

        if (clickedElement) {
            // 设置选中元件
            if (selectedElement) {
                selectedElement->SetSelected(false);
            }
            selectedElement = clickedElement;
            selectedElement->SetSelected(true);

            // 创建上下文菜单
            wxMenu contextMenu;
            contextMenu.Append(wxID_DELETE, "Delete Element");
            contextMenu.Append(wxID_PROPERTIES, "Properties");

            PopupMenu(&contextMenu, event.GetPosition());  // 弹出菜单
            Refresh();  // 刷新显示
        }
        else {
            // 检查是否点击了导线
            for (auto& wire : wires) {
                if (wire->ContainsPoint(pos)) {
                    return;
                }
            }

            // 点击空白处清除选中
            if (selectedElement) {
                selectedElement->SetSelected(false);
                selectedElement = nullptr;
                Refresh();  // 刷新显示
            }
        }
    }

    // 鼠标滚轮事件
    void OnMouseWheel(wxMouseEvent& event) {
        if (event.ControlDown()) {
            // Ctrl+滚轮：缩放
            if (event.GetWheelRotation() > 0) {
                ZoomIn();
            }
            else {
                ZoomOut();
            }
        }
        else {
            // 普通滚轮：滚动
            event.Skip();  // 让父类处理滚动
        }
    }

    // 键盘按下事件
    void OnKeyDown(wxKeyEvent& event) {
        int vx, vy;
        GetViewStart(&vx, &vy);
        wxSize clientSize = GetClientSize();

        switch (event.GetKeyCode()) {
        case WXK_DELETE:
            DeleteSelectedElement();  // 删除选中元件
            break;
        case WXK_ESCAPE:
            if (autoPlaceMode) {
                // 退出自动放置模式
                autoPlaceMode = false;
                SetCursor(wxCursor(wxCURSOR_ARROW));
                Refresh();
            }
            else if (wiringMode && startPin) {
                startPin = nullptr;  // 取消连线
                Refresh();
            }
            break;
        case 'G':
            ToggleGrid();  // 切换网格显示
            break;
        case 'Z':
            if (event.ControlDown()) {
                if (event.ShiftDown()) {
                    Redo(); // Ctrl+Shift+Z 重做
                }
                else {
                    Undo(); // Ctrl+Z 撤销
                }
            }
            break;
        case 'Y':
            if (event.ControlDown()) {
                Redo(); // Ctrl+Y 重做
            }
            break;
            // 添加键盘滚动支持
        case WXK_LEFT:
            Scroll(vx - 1, vy);
            Refresh();
            break;
        case WXK_RIGHT:
            Scroll(vx + 1, vy);
            Refresh();
            break;
        case WXK_UP:
            Scroll(vx, vy - 1);
            Refresh();
            break;
        case WXK_DOWN:
            Scroll(vx, vy + 1);
            Refresh();
            break;
        case WXK_PAGEUP:
            Scroll(vx, vy - (clientSize.y / 20));
            Refresh();
            break;
        case WXK_PAGEDOWN:
            Scroll(vx, vy + (clientSize.y / 20));
            Refresh();
            break;
        case WXK_HOME:
            Scroll(0, 0);
            Refresh();
            break;
        case WXK_END:
            // 滚动到右下角（简化实现）
            Scroll(100, 100);
            Refresh();
            break;

        default:
            event.Skip();
            break;
        }
    }

    // 窗口大小改变事件
    void OnSize(wxSizeEvent& event) {
        Refresh();  // 刷新显示
        event.Skip();  // 传递事件
    }

    // 滚动事件处理
    void OnScroll(wxScrollWinEvent& event) {
        Refresh();  // 滚动时刷新显示
        event.Skip();  // 继续处理事件
    }

    // 在指定位置查找引脚
    Pin* FindPinAt(const wxPoint& pos) {
        for (auto& element : elements) {
            for (auto pin : element->GetPins()) {
                int dx = pin->GetX() - pos.x;
                int dy = pin->GetY() - pos.y;
                if (std::sqrt(dx * dx + dy * dy) < 5) {  // 5像素范围内
                    return pin;
                }
            }
        }
        return nullptr;  // 未找到引脚
    }

    // 获取工具名称
    wxString GetToolName(ElementType tool) {
        switch (tool) {
        case TYPE_SELECT: return "Selection Tool";
        case TYPE_TOGGLE_VALUE: return "Toggle Value Tool";
        case TYPE_AND: return "AND Gate";
        case TYPE_OR: return "OR Gate";
        case TYPE_NOT: return "NOT Gate";
        case TYPE_XOR: return "XOR Gate";
        case TYPE_NAND: return "NAND Gate";
        case TYPE_NOR: return "NOR Gate";
        case TYPE_INPUT: return "Input Pin";
        case TYPE_OUTPUT: return "Output Pin";
        case TYPE_WIRE: return "Wire Tool";
        default: return "Unknown Tool";
        }
    }

    // 获取当前视图中心
    wxPoint GetViewCenter() {
        int vx, vy;
        GetViewStart(&vx, &vy);
        wxSize clientSize = GetClientSize();
        return wxPoint(
            vx * 10 + clientSize.x / (2 * zoomLevel),
            vy * 10 + clientSize.y / (2 * zoomLevel)
        );
    }

    // 将视图中心设置为指定位置
    void CenterView(const wxPoint& center) {
        wxSize clientSize = GetClientSize();
        int newVX = (center.x - clientSize.x / (2 * zoomLevel)) / 10;
        int newVY = (center.y - clientSize.y / (2 * zoomLevel)) / 10;
        Scroll(newVX, newVY);
    }

    // 更新滚动条
    void UpdateScrollbars() {
        SetVirtualSize(
            virtualSize.x * zoomLevel,
            virtualSize.y * zoomLevel
        );
        SetScrollRate(20 * zoomLevel, 20 * zoomLevel);
    }

};
