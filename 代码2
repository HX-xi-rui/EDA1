#include <wx/wx.h>                    // wxWidgets主头文件
#include <wx/dcbuffer.h>              // 双缓冲绘图
#include <wx/filedlg.h>               // 文件对话框
#include <wx/filename.h>              // 文件名处理
#include <wx/tokenzr.h>               // 字符串分割
#include <wx/artprov.h>               // 图标资源
#include <wx/splitter.h>              // 分割窗口
#include <wx/propgrid/propgrid.h>     // 属性网格
#include <wx/numdlg.h>                // 数字输入对话框
#include <wx/grid.h>                  // 网格控件
#include <vector>                     // 向量容器
#include <memory>                     // 智能指针
#include <cmath>                      // 数学函数
#include <algorithm>                  // 算法函数
#include <random>                     // 随机数
#include <map>                        // 映射容器
#include <set>                        // 集合容器
#include <wx/treectrl.h>              // 树形控件

// 前向声明 - 避免循环依赖
class CircuitElement;
class Gate;
class Wire;
class CircuitCanvas;
class TruthTableDialog;

// 元素类型枚举 - 定义所有可用的电路元件类型
enum ElementType {
    TYPE_INPUT,           // 输入引脚
    TYPE_OUTPUT,          // 输出引脚  
    TYPE_AND,             // 与门
    TYPE_OR,              // 或门
    TYPE_NOT,             // 非门
    TYPE_XOR,             // 异或门
    TYPE_NAND,            // 与非门
    TYPE_NOR,             // 或非门
    TYPE_WIRE,            // 导线工具
    TYPE_SELECT,          // 选择工具
    TYPE_TOGGLE_VALUE,    // 切换值工具
    TYPE_CLOCK,           // 时钟信号
    TYPE_D_FLIPFLOP,      // D触发器
    TYPE_JK_FLIPFLOP,     // JK触发器
    TYPE_T_FLIPFLOP,      // T触发器
    TYPE_REGISTER,        // 寄存器
    TYPE_COUNTER ,         // 计数器
    ID_TOGGLE_TREE
};

// 引脚类
class Pin {
public:
    // 构造函数：初始化引脚位置、类型和父元素
    Pin(int x, int y, bool isInput, CircuitElement* parent)
        : posX(x), posY(y), input(isInput), value(false),
        connectedWire(nullptr), parentElement(parent) {
    }

    // Getter方法 - 获取引脚属性
    int GetX() const { return posX; }
    int GetY() const { return posY; }
    bool IsInput() const { return input; }
    bool GetValue() const { return value; }

    // Setter方法 - 设置引脚属性  
    void SetValue(bool val) { value = val; }
    void SetConnectedWire(Wire* wire) { connectedWire = wire; }
    void SetPosition(int x, int y) { posX = x; posY = y; }

    // 获取连接的导线
    Wire* GetConnectedWire() const { return connectedWire; }

    // 获取父元素
    CircuitElement* GetParent() const { return parentElement; }

    // 生成唯一ID - 用于序列化
    wxString GetId() const {
        return wxString::Format("%p_%d", parentElement, input ? 1 : 0);
    }

private:
    int posX, posY;           // 引脚坐标
    bool input;               // 是否为输入引脚
    bool value;               // 逻辑值(true=1, false=0)
    Wire* connectedWire;      // 连接的导线
    CircuitElement* parentElement; // 所属的电路元件
};

// 电路元素基类
class CircuitElement {
public:
    // 构造函数：初始化类型和位置
    CircuitElement(ElementType type, int x, int y)
        : type(type), posX(x), posY(y), selected(false) {
    }

    virtual ~CircuitElement() {}  // 虚析构函数

    // 基本属性访问方法
    ElementType GetType() const { return type; }
    int GetX() const { return posX; }
    int GetY() const { return posY; }
    bool IsSelected() const { return selected; }
    void SetSelected(bool sel) { selected = sel; }

    // 设置位置并更新所有引脚位置
    void SetPosition(int x, int y) {
        int dx = x - posX;
        int dy = y - posY;
        posX = x;
        posY = y;

        // 更新引脚位置 - 保持相对位置
        for (auto pin : GetPins()) {
            pin->SetPosition(pin->GetX() + dx, pin->GetY() + dy);
        }
    }

    // 纯虚函数 - 子类必须实现
    virtual void Draw(wxDC& dc) = 0;              // 绘制元件
    virtual void Update() = 0;                    // 更新逻辑状态
    virtual std::vector<Pin*> GetPins() = 0;      // 获取所有引脚
    virtual wxRect GetBoundingBox() const = 0;    // 获取边界框
    virtual wxString GetName() const = 0;         // 获取名称
    virtual wxString GetDisplayName() const = 0;  // 获取显示名称

    // 序列化接口
    virtual void Serialize(wxString& data) const = 0;  // 序列化到字符串
    virtual void Deserialize(const wxString& data) = 0; // 从字符串反序列化

    // 属性网格接口
    virtual void GetProperties(wxPropertyGrid* pg) const = 0; // 获取属性
    virtual void SetProperties(wxPropertyGrid* pg) = 0;       // 设置属性

protected:
    ElementType type;    // 元件类型
    int posX, posY;      // 位置坐标
    bool selected;       // 是否被选中
};

// 时钟信号类
class ClockElement : public CircuitElement {
public:
    ClockElement(int x, int y, int frequency = 1)
        : CircuitElement(TYPE_CLOCK, x, y), value(false), frequency(frequency),
        counter(0), enabled(true) {
        // 输出引脚
        pins.push_back(std::make_unique<Pin>(x + 20, y, false, this));
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(value ? *wxGREEN_BRUSH : *wxWHITE_BRUSH);

        // 绘制时钟符号
        dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
        dc.DrawText("CLK", posX - 12, posY - 7);

        // 显示频率
        wxString freqText = wxString::Format("%dHz", frequency);
        dc.SetTextForeground(*wxBLUE);
        wxFont smallFont = dc.GetFont();
        smallFont.SetPointSize(7);
        dc.SetFont(smallFont);
        dc.DrawText(freqText, posX - 10, posY + 10);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }

        // 显示当前值
        dc.SetTextForeground(*wxRED);
        wxString valText = value ? "1" : "0";
        dc.DrawText(valText, posX + 15, posY - 5);
    }

    virtual void Update() override {
        if (!enabled) return;

        counter++;
        if (counter >= frequency) {
            value = !value;
            counter = 0;
        }

        if (!pins.empty()) {
            pins[0]->SetValue(value);
        }
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 15, posY - 15, 30, 30);
    }

    virtual wxString GetName() const override {
        return "CLOCK";
    }

    virtual wxString GetDisplayName() const override {
        return wxString::Format("Clock (%dHz)", frequency);
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,%d,%d,", type, posX, posY, frequency, enabled ? 1 : 0);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 5) {
            long typeVal, x, y, freq, en;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            tokenizer.GetNextToken().ToLong(&freq);
            tokenizer.GetNextToken().ToLong(&en);
            SetPosition(x, y);
            frequency = freq;
            enabled = en != 0;
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxIntProperty("Frequency", "Frequency", frequency));
        pg->Append(new wxBoolProperty("Enabled", "Enabled", enabled));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        wxVariant freqVar = pg->GetPropertyValue("Frequency");
        wxVariant enabledVar = pg->GetPropertyValue("Enabled");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
        if (freqVar.IsType("long")) {
            frequency = freqVar.GetLong();
        }
        if (enabledVar.IsType("bool")) {
            enabled = enabledVar.GetBool();
        }
    }

    void SetFrequency(int freq) { frequency = freq; }
    int GetFrequency() const { return frequency; }
    void SetEnabled(bool en) { enabled = en; }
    bool IsEnabled() const { return enabled; }

private:
    std::vector<std::unique_ptr<Pin>> pins;
    bool value;
    int frequency;
    int counter;
    bool enabled;
};

// D触发器类
class DFlipFlop : public CircuitElement {
public:
    DFlipFlop(int x, int y)
        : CircuitElement(TYPE_D_FLIPFLOP, x, y), q(false), lastClock(false) {
        // 输入引脚: D, CLK
        pins.push_back(std::make_unique<Pin>(x - 20, y - 15, true, this));   // D
        pins.push_back(std::make_unique<Pin>(x - 20, y, true, this));        // CLK
        // 输出引脚: Q, Q'
        pins.push_back(std::make_unique<Pin>(x + 20, y - 10, false, this));  // Q
        pins.push_back(std::make_unique<Pin>(x + 20, y + 10, false, this));  // Q'
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        // 绘制D触发器符号
        dc.DrawRectangle(posX - 15, posY - 20, 30, 40);
        dc.DrawText("D", posX - 12, posY - 15);
        dc.DrawText("FF", posX - 10, posY - 5);

        // 绘制引脚标签
        dc.SetTextForeground(*wxBLACK);
        wxFont smallFont = dc.GetFont();
        smallFont.SetPointSize(6);
        dc.SetFont(smallFont);

        dc.DrawText("D", posX - 25, posY - 18);
        dc.DrawText("CLK", posX - 30, posY - 3);
        dc.DrawText("Q", posX + 15, posY - 13);
        dc.DrawText("Q'", posX + 12, posY + 13);

        // 显示当前状态
        dc.SetTextForeground(q ? *wxRED : *wxBLUE);
        wxString stateText = q ? "Q=1" : "Q=0";
        dc.DrawText(stateText, posX - 12, posY + 5);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
    }

    virtual void Update() override {
        if (pins.size() < 4) return;

        bool d = pins[0]->GetValue();
        bool clock = pins[1]->GetValue();

        // 时钟上升沿触发
        if (clock && !lastClock) {
            q = d;
        }
        lastClock = clock;

        // 设置输出
        pins[2]->SetValue(q);      // Q
        pins[3]->SetValue(!q);     // Q'
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 25, 40, 50);
    }

    virtual wxString GetName() const override {
        return "D_FLIPFLOP";
    }

    virtual wxString GetDisplayName() const override {
        return "D Flip-Flop";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,%d,", type, posX, posY, q ? 1 : 0);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 4) {
            long typeVal, x, y, qVal;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            tokenizer.GetNextToken().ToLong(&qVal);
            SetPosition(x, y);
            q = qVal != 0;
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxBoolProperty("Q Output", "Q", q));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        wxVariant qVar = pg->GetPropertyValue("Q");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
        if (qVar.IsType("bool")) {
            q = qVar.GetBool();
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins;
    bool q;
    bool lastClock;
};

// JK触发器类
class JKFlipFlop : public CircuitElement {
public:
    JKFlipFlop(int x, int y)
        : CircuitElement(TYPE_JK_FLIPFLOP, x, y), q(false), lastClock(false) {
        // 输入引脚: J, K, CLK
        pins.push_back(std::make_unique<Pin>(x - 20, y - 20, true, this));   // J
        pins.push_back(std::make_unique<Pin>(x - 20, y, true, this));        // K
        pins.push_back(std::make_unique<Pin>(x - 20, y + 20, true, this));   // CLK
        // 输出引脚: Q, Q'
        pins.push_back(std::make_unique<Pin>(x + 20, y - 10, false, this));  // Q
        pins.push_back(std::make_unique<Pin>(x + 20, y + 10, false, this));  // Q'
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        // 绘制JK触发器符号
        dc.DrawRectangle(posX - 15, posY - 25, 30, 50);
        dc.DrawText("JK", posX - 10, posY - 15);
        dc.DrawText("FF", posX - 10, posY - 5);

        // 绘制引脚标签
        dc.SetTextForeground(*wxBLACK);
        wxFont smallFont = dc.GetFont();
        smallFont.SetPointSize(6);
        dc.SetFont(smallFont);

        dc.DrawText("J", posX - 25, posY - 23);
        dc.DrawText("K", posX - 25, posY - 3);
        dc.DrawText("CLK", posX - 30, posY + 17);
        dc.DrawText("Q", posX + 15, posY - 13);
        dc.DrawText("Q'", posX + 12, posY + 13);

        // 显示当前状态
        dc.SetTextForeground(q ? *wxRED : *wxBLUE);
        wxString stateText = q ? "Q=1" : "Q=0";
        dc.DrawText(stateText, posX - 12, posY + 10);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
    }

    virtual void Update() override {
        if (pins.size() < 5) return;

        bool j = pins[0]->GetValue();
        bool k = pins[1]->GetValue();
        bool clock = pins[2]->GetValue();

        // 时钟上升沿触发
        if (clock && !lastClock) {
            if (j && !k) {
                q = true;      // 置位
            }
            else if (!j && k) {
                q = false;     // 复位
            }
            else if (j && k) {
                q = !q;        // 翻转
            }
            // J=0,K=0 时保持状态不变
        }
        lastClock = clock;

        // 设置输出
        pins[3]->SetValue(q);      // Q
        pins[4]->SetValue(!q);     // Q'
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 30, 40, 60);
    }

    virtual wxString GetName() const override {
        return "JK_FLIPFLOP";
    }

    virtual wxString GetDisplayName() const override {
        return "JK Flip-Flop";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,%d,", type, posX, posY, q ? 1 : 0);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 4) {
            long typeVal, x, y, qVal;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            tokenizer.GetNextToken().ToLong(&qVal);
            SetPosition(x, y);
            q = qVal != 0;
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxBoolProperty("Q Output", "Q", q));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        wxVariant qVar = pg->GetPropertyValue("Q");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
        if (qVar.IsType("bool")) {
            q = qVar.GetBool();
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins;
    bool q;
    bool lastClock;
};

// T触发器类
class TFlipFlop : public CircuitElement {
public:
    TFlipFlop(int x, int y)
        : CircuitElement(TYPE_T_FLIPFLOP, x, y), q(false), lastClock(false) {
        // 输入引脚: T, CLK
        pins.push_back(std::make_unique<Pin>(x - 20, y - 10, true, this));   // T
        pins.push_back(std::make_unique<Pin>(x - 20, y + 10, true, this));   // CLK
        // 输出引脚: Q, Q'
        pins.push_back(std::make_unique<Pin>(x + 20, y - 10, false, this));  // Q
        pins.push_back(std::make_unique<Pin>(x + 20, y + 10, false, this));  // Q'
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        // 绘制T触发器符号
        dc.DrawRectangle(posX - 15, posY - 20, 30, 40);
        dc.DrawText("T", posX - 5, posY - 15);
        dc.DrawText("FF", posX - 10, posY - 5);

        // 绘制引脚标签
        dc.SetTextForeground(*wxBLACK);
        wxFont smallFont = dc.GetFont();
        smallFont.SetPointSize(6);
        dc.SetFont(smallFont);

        dc.DrawText("T", posX - 25, posY - 13);
        dc.DrawText("CLK", posX - 30, posY + 7);
        dc.DrawText("Q", posX + 15, posY - 13);
        dc.DrawText("Q'", posX + 12, posY + 13);

        // 显示当前状态
        dc.SetTextForeground(q ? *wxRED : *wxBLUE);
        wxString stateText = q ? "Q=1" : "Q=0";
        dc.DrawText(stateText, posX - 12, posY + 5);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
    }

    virtual void Update() override {
        if (pins.size() < 4) return;

        bool t = pins[0]->GetValue();
        bool clock = pins[1]->GetValue();

        // 时钟上升沿触发
        if (clock && !lastClock) {
            if (t) {
                q = !q;  // 翻转
            }
            // T=0 时保持状态不变
        }
        lastClock = clock;

        // 设置输出
        pins[2]->SetValue(q);      // Q
        pins[3]->SetValue(!q);     // Q'
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 25, 40, 50);
    }

    virtual wxString GetName() const override {
        return "T_FLIPFLOP";
    }

    virtual wxString GetDisplayName() const override {
        return "T Flip-Flop";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,%d,", type, posX, posY, q ? 1 : 0);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 4) {
            long typeVal, x, y, qVal;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            tokenizer.GetNextToken().ToLong(&qVal);
            SetPosition(x, y);
            q = qVal != 0;
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxBoolProperty("Q Output", "Q", q));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        wxVariant qVar = pg->GetPropertyValue("Q");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
        if (qVar.IsType("bool")) {
            q = qVar.GetBool();
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins;
    bool q;
    bool lastClock;
};

// 寄存器类（4位）
class RegisterElement : public CircuitElement {
public:
    RegisterElement(int x, int y)
        : CircuitElement(TYPE_REGISTER, x, y), lastClock(false) {
        // 初始化寄存器值为0
        for (int i = 0; i < 4; i++) {
            data[i] = false;
        }

        // 输入引脚: D0-D3, CLK, LOAD
        for (int i = 0; i < 4; i++) {
            pins.push_back(std::make_unique<Pin>(x - 30, y - 30 + i * 15, true, this)); // D0-D3
        }
        pins.push_back(std::make_unique<Pin>(x - 30, y + 30, true, this));  // CLK
        pins.push_back(std::make_unique<Pin>(x - 30, y + 45, true, this));  // LOAD

        // 输出引脚: Q0-Q3
        for (int i = 0; i < 4; i++) {
            pins.push_back(std::make_unique<Pin>(x + 30, y - 30 + i * 15, false, this)); // Q0-Q3
        }
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        // 绘制寄存器符号
        dc.DrawRectangle(posX - 25, posY - 35, 50, 70);
        dc.DrawText("REG", posX - 15, posY - 25);
        dc.DrawText("4-bit", posX - 18, posY - 10);

        // 绘制引脚标签
        dc.SetTextForeground(*wxBLACK);
        wxFont smallFont = dc.GetFont();
        smallFont.SetPointSize(6);
        dc.SetFont(smallFont);

        // 输入引脚标签
        for (int i = 0; i < 4; i++) {
            dc.DrawText(wxString::Format("D%d", i), posX - 35, y - 33 + i * 15);
        }
        dc.DrawText("CLK", posX - 35, y + 27);
        dc.DrawText("LD", posX - 35, y + 42);

        // 输出引脚标签
        for (int i = 0; i < 4; i++) {
            dc.DrawText(wxString::Format("Q%d", i), posX + 25, y - 33 + i * 15);
        }

        // 显示当前值
        dc.SetTextForeground(*wxBLUE);
        wxString valueText = GetValueString();
        dc.DrawText(valueText, posX - 20, posY + 10);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
    }

    virtual void Update() override {
        if (pins.size() < 10) return;

        bool clock = pins[4]->GetValue();
        bool load = pins[5]->GetValue();

        // 时钟上升沿触发且LOAD为高时加载数据
        if (clock && !lastClock && load) {
            for (int i = 0; i < 4; i++) {
                data[i] = pins[i]->GetValue();
            }
        }
        lastClock = clock;

        // 设置输出
        for (int i = 0; i < 4; i++) {
            pins[6 + i]->SetValue(data[i]);
        }
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 30, posY - 40, 60, 80);
    }

    virtual wxString GetName() const override {
        return "REGISTER";
    }

    virtual wxString GetDisplayName() const override {
        return "4-bit Register";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,", type, posX, posY);
        for (int i = 0; i < 4; i++) {
            data += wxString::Format("%d,", this->data[i] ? 1 : 0);
        }
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 7) {
            long typeVal, x, y;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            SetPosition(x, y);

            for (int i = 0; i < 4; i++) {
                long val;
                tokenizer.GetNextToken().ToLong(&val);
                this->data[i] = val != 0;
            }
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxStringProperty("Value", "Value", GetValueString()));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins;
    bool data[4];
    bool lastClock;
    int y;

    wxString GetValueString() const {
        int value = 0;
        for (int i = 0; i < 4; i++) {
            if (data[i]) {
                value |= (1 << i);
            }
        }
        return wxString::Format("0x%X", value);
    }
};

// 逻辑门基类（原有代码保持不变）
class Gate : public CircuitElement {
public:
    Gate(ElementType type, int x, int y) : CircuitElement(type, x, y) {
        // 根据门类型创建输入输出引脚
        if (type == TYPE_NOT) {
            inputs.push_back(std::make_unique<Pin>(x - 20, y, true, this));
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
        else {
            inputs.push_back(std::make_unique<Pin>(x - 20, y - 10, true, this));
            inputs.push_back(std::make_unique<Pin>(x - 20, y + 10, true, this));
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        switch (type) {
        case TYPE_AND:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("AND", posX - 12, posY - 7);
            break;
        case TYPE_OR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("OR", posX - 8, posY - 7);
            break;
        case TYPE_NOT:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("NOT", posX - 12, posY - 7);
            break;
        case TYPE_XOR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("XOR", posX - 12, posY - 7);
            break;
        case TYPE_NAND:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("NAND", posX - 15, posY - 7);
            break;
        case TYPE_NOR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("NOR", posX - 12, posY - 7);
            break;
        default:
            break;
        }

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : inputs) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
        for (auto& pin : outputs) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }

        // 显示引脚值（在仿真时）
        if (wxWindow::FindWindowById(wxID_ANY)) {
            dc.SetTextForeground(*wxBLUE);
            wxFont smallFont = dc.GetFont();
            smallFont.SetPointSize(8);
            dc.SetFont(smallFont);

            for (auto& pin : inputs) {
                wxString val = pin->GetValue() ? "1" : "0";
                dc.DrawText(val, pin->GetX() - 8, pin->GetY() - 8);
            }
            for (auto& pin : outputs) {
                wxString val = pin->GetValue() ? "1" : "0";
                dc.DrawText(val, pin->GetX() + 5, pin->GetY() - 8);
            }
        }
    }

    //更新逻辑门状态
    virtual void Update() override {
        if (inputs.empty() || outputs.empty()) return;

        bool val0 = inputs[0]->GetConnectedWire() ? inputs[0]->GetValue() : false;
        bool val1 = inputs.size() > 1 && inputs[1]->GetConnectedWire() ? inputs[1]->GetValue() : false;

        bool result = false;

        switch (type) {
        case TYPE_AND:
            result = val0 && val1;
            break;
        case TYPE_OR:
            result = val0 || val1;
            break;
        case TYPE_NOT:
            result = !val0;
            break;
        case TYPE_XOR:
            result = val0 != val1;
            break;
        case TYPE_NAND:
            result = !(val0 && val1);
            break;
        case TYPE_NOR:
            result = !(val0 || val1);
            break;
        default:
            break;
        }

        outputs[0]->SetValue(result);
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> allPins;
        for (auto& pin : inputs) {
            allPins.push_back(pin.get());
        }
        for (auto& pin : outputs) {
            allPins.push_back(pin.get());
        }
        return allPins;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 20, 40, 40);
    }

    virtual wxString GetName() const override {
        switch (type) {
        case TYPE_AND: return "AND";
        case TYPE_OR: return "OR";
        case TYPE_NOT: return "NOT";
        case TYPE_XOR: return "XOR";
        case TYPE_NAND: return "NAND";
        case TYPE_NOR: return "NOR";
        default: return "Unknown";
        }
    }

    virtual wxString GetDisplayName() const override {
        return GetName() + " Gate";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,", type, posX, posY);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 3) {
            long typeVal, x, y;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            SetPosition(x, y);
        }
    }

    //获取属性
    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
    }

    //设置属性
    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> inputs; //输入引脚
    std::vector<std::unique_ptr<Pin>> outputs;//输出引脚
};

// 输入输出引脚类（原有代码保持不变）
class InputOutput : public CircuitElement {
public:
    InputOutput(ElementType type, int x, int y, const wxString& name = "")
        : CircuitElement(type, x, y), value(false), customName(name) {
        // 输入引脚在右侧有输出引脚，输出引脚在左侧有输入引脚
        if (type == TYPE_INPUT) {
            pins.push_back(std::make_unique<Pin>(x + 20, y, false, this)); // 输出引脚
        }
        else {
            pins.push_back(std::make_unique<Pin>(x - 20, y, true, this)); // 输入引脚
        }
    }

    // 修改 InputOutput 类的 Draw 方法，使输入元件的值显示更明显
    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));

        // 输入元件使用不同的颜色表示状态
        if (type == TYPE_INPUT) {
            dc.SetBrush(value ? *wxGREEN_BRUSH : *wxYELLOW_BRUSH);
        }
        else {
            dc.SetBrush(value ? *wxGREEN_BRUSH : *wxWHITE_BRUSH);
        }

        dc.DrawRectangle(posX - 15, posY - 15, 30, 30);

        // 显示标签
        wxString label;
        if (!customName.empty()) {
            label = customName;
        }
        else if (type == TYPE_INPUT) {
            label = "IN";
        }
        else {
            label = "OUT";
        }
        dc.DrawText(label, posX - (label.Length() > 2 ? 12 : 7), posY - 7);

        // 显示当前值 - 使用更大的字体和更明显的颜色
        dc.SetTextForeground(value ? *wxRED : *wxBLUE);
        wxString valueText = value ? "1" : "0";
        wxFont valueFont = dc.GetFont();
        valueFont.SetPointSize(10);
        valueFont.SetWeight(wxFONTWEIGHT_BOLD);
        dc.SetFont(valueFont);

        wxSize textSize = dc.GetTextExtent(valueText);

        if (type == TYPE_INPUT) {
            dc.DrawText(valueText, posX + 15 - textSize.GetWidth() - 2, posY - textSize.GetHeight() / 2);
        }
        else {
            dc.DrawText(valueText, posX - 15 + 2, posY - textSize.GetHeight() / 2);
        }

        // 恢复默认字体
        valueFont.SetPointSize(8);
        valueFont.SetWeight(wxFONTWEIGHT_NORMAL);
        dc.SetFont(valueFont);

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        dc.SetTextForeground(*wxBLACK);
        for (auto& pin : pins) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
    }

    virtual void Update() override {
        // 对于输入元件：把自身的 value 写到它的输出引脚（驱动信号）
        if (type == TYPE_INPUT) {
            if (!pins.empty()) {
                // pins[0] 是输出引脚（构造时如此）
                pins[0]->SetValue(value);
            }
        }
        // 对于输出元件：从连接的输入引脚读值到自身 value（显示/记录输出）
        else if (type == TYPE_OUTPUT) {
            if (!pins.empty()) {
                // pins[0] 是输入引脚（构造时如此）
                value = pins[0]->GetValue();
            }
        }
    }

    void SetValue(bool val) { value = val; }
    bool GetValue() const { return value; }
    void SetName(const wxString& name) { customName = name; }
    wxString GetCustomName() const { return customName; }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> pinPtrs;
        for (auto& pin : pins) {
            pinPtrs.push_back(pin.get());
        }
        return pinPtrs;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 15, posY - 15, 30, 30);
    }

    virtual wxString GetName() const override {
        return type == TYPE_INPUT ? "INPUT" : "OUTPUT";
    }

    virtual wxString GetDisplayName() const override {
        if (!customName.empty()) {
            return customName;
        }
        return type == TYPE_INPUT ? "Input Pin" : "Output Pin";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,%d,%s,", type, posX, posY, value ? 1 : 0, customName);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 4) {
            long typeVal, x, y, val;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            tokenizer.GetNextToken().ToLong(&val);
            SetPosition(x, y);
            value = val != 0;

            if (tokenizer.HasMoreTokens()) {
                customName = tokenizer.GetNextToken();
            }
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
        pg->Append(new wxStringProperty("Name", "Name", customName));
        pg->Append(new wxBoolProperty("Value", "Value", value));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        wxVariant nameVar = pg->GetPropertyValue("Name");
        wxVariant valueVar = pg->GetPropertyValue("Value");

        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
        if (nameVar.IsType("string")) {
            customName = nameVar.GetString();
        }
        if (valueVar.IsType("bool")) {
            value = valueVar.GetBool();
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> pins; //引脚列表
    bool value;
    wxString customName; //自定义名称
};

// 导线类（原有代码保持不变）
class Wire {
public:
    Wire(Pin* start, Pin* end) : startPin(start), endPin(end) {
        // 建立双向连接
        start->SetConnectedWire(this);
        end->SetConnectedWire(this);
    }

    // 绘制导线
    void Draw(wxDC& dc) {
        // 根据信号值选择颜色：绿色=1，红色=0
        bool value = startPin->GetValue();
        dc.SetPen(value ? wxPen(*wxGREEN, 2) : wxPen(*wxRED, 2));
        dc.DrawLine(startPin->GetX(), startPin->GetY(), endPin->GetX(), endPin->GetY());
    }

    // 更新导线状态 - 传递信号值
    void Update() {
        // 将起始引脚的值传递到结束引脚
        if (startPin && endPin) {
            endPin->SetValue(startPin->GetValue());
        }
    }

    Pin* GetStartPin() const { return startPin; }
    Pin* GetEndPin() const { return endPin; }

    // 检查点是否在导线附近
    bool ContainsPoint(const wxPoint& point) const {
        if (!startPin || !endPin) return false;

        int x1 = startPin->GetX(), y1 = startPin->GetY();
        int x2 = endPin->GetX(), y2 = endPin->GetY();

        // 计算点到线段的距离
        double A = point.x - x1;
        double B = point.y - y1;
        double C = x2 - x1;
        double D = y2 - y1;

        double dot = A * C + B * D;
        double len_sq = C * C + D * D;
        double param = (len_sq != 0) ? dot / len_sq : -1;

        double xx, yy;

        if (param < 0) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        double dx = point.x - xx;
        double dy = point.y - yy;
        return std::sqrt(dx * dx + dy * dy) < 5;
    }

    void Serialize(wxString& data) const {
        data += wxString::Format("wire,%s,%s,",
            startPin->GetId(), endPin->GetId());
    }

private:
    Pin* startPin;
    Pin* endPin;
};

// 画布类 - 修改以支持时序元件
class CircuitCanvas : public wxWindow {
public:
    CircuitCanvas(wxWindow* parent) : wxWindow(parent, wxID_ANY),
        currentTool(TYPE_SELECT), wiringMode(false), selectedElement(nullptr),
        startPin(nullptr), simulating(false), showGrid(true), zoomLevel(1.0),
        autoPlaceMode(false), autoPlaceType(TYPE_SELECT) {

        // 设置双缓冲避免闪烁
        SetBackgroundStyle(wxBG_STYLE_PAINT);

        Bind(wxEVT_PAINT, &CircuitCanvas::OnPaint, this);
        Bind(wxEVT_LEFT_DOWN, &CircuitCanvas::OnLeftDown, this);
        Bind(wxEVT_LEFT_UP, &CircuitCanvas::OnLeftUp, this);
        Bind(wxEVT_MOTION, &CircuitCanvas::OnMouseMove, this);
        Bind(wxEVT_RIGHT_DOWN, &CircuitCanvas::OnRightDown, this);
        Bind(wxEVT_MOUSEWHEEL, &CircuitCanvas::OnMouseWheel, this);
        Bind(wxEVT_KEY_DOWN, &CircuitCanvas::OnKeyDown, this);
        Bind(wxEVT_SIZE, &CircuitCanvas::OnSize, this);
        Bind(wxEVT_MENU, &CircuitCanvas::OnContextMenu, this);
        SetFocus();
    }

    // 修改创建元件方法以支持时序元件
    void CreateElementAtPosition(ElementType type, const wxPoint& pos) {
        if (type >= TYPE_AND && type <= TYPE_NOR) {
            elements.push_back(std::make_unique<Gate>(type, pos.x, pos.y));
        }
        else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
            elements.push_back(std::make_unique<InputOutput>(type, pos.x, pos.y));
        }
        else if (type == TYPE_CLOCK) {
            elements.push_back(std::make_unique<ClockElement>(pos.x, pos.y));
        }
        else if (type == TYPE_D_FLIPFLOP) {
            elements.push_back(std::make_unique<DFlipFlop>(pos.x, pos.y));
        }
        else if (type == TYPE_JK_FLIPFLOP) {
            elements.push_back(std::make_unique<JKFlipFlop>(pos.x, pos.y));
        }
        else if (type == TYPE_T_FLIPFLOP) {
            elements.push_back(std::make_unique<TFlipFlop>(pos.x, pos.y));
        }
        else if (type == TYPE_REGISTER) {
            elements.push_back(std::make_unique<RegisterElement>(pos.x, pos.y));
        }
        Refresh();
    }

    // 其余方法保持不变...
    // [原有代码保持不变，只添加了时序元件的创建支持]
      // 新增：设置自动放置模式
    void SetAutoPlaceMode(ElementType type) {
        autoPlaceMode = (type != TYPE_SELECT && type != TYPE_WIRE);
        autoPlaceType = type;
        currentTool = type;
        wiringMode = (type == TYPE_WIRE);

        if (autoPlaceMode) {
            // 设置鼠标光标为十字准星
            SetCursor(wxCursor(wxCURSOR_CROSS));
            // 显示提示信息
            wxWindow* topWindow = wxGetTopLevelParent(this);
            if (topWindow) {
                wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
                if (statusBar) {
                    statusBar->SetStatusText("Click on canvas to place " + GetToolName(type));
                }
            }
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));
        }

        Refresh();
    }



    void OnContextMenu(wxCommandEvent& event) {
        switch (event.GetId()) {
        case wxID_DELETE:
            DeleteSelectedElement();
            break;
        case wxID_PROPERTIES:
            break;
        default:
            break;
        }
    }

    // 设置当前工具
    void SetCurrentTool(ElementType tool) {
        currentTool = tool;
        wiringMode = (tool == TYPE_WIRE);
        autoPlaceMode = false; // 重置自动放置模式

        if (!wiringMode) {
            startPin = nullptr;
        }

        // 设置合适的鼠标光标
        if (tool == TYPE_TOGGLE_VALUE) {
            SetCursor(wxCursor(wxCURSOR_HAND));
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));
        }
        Refresh();
    }

    void DeleteSelectedElement() {
        if (selectedElement) {
            wxMessageDialog dialog(GetParent(),
                "Are you sure you want to delete the selected element?",
                "Confirm Delete",
                wxYES_NO | wxICON_QUESTION);

            if (dialog.ShowModal() == wxID_YES) {
                auto pins = selectedElement->GetPins();
                for (auto& pin : pins) {
                    for (auto wireIt = wires.begin(); wireIt != wires.end(); ) {
                        if ((*wireIt)->GetStartPin() == pin || (*wireIt)->GetEndPin() == pin) {
                            wireIt = wires.erase(wireIt);
                        }
                        else {
                            ++wireIt;
                        }
                    }
                }

                auto it = std::find_if(elements.begin(), elements.end(),
                    [this](const std::unique_ptr<CircuitElement>& elem) {
                        return elem.get() == selectedElement;
                    });

                if (it != elements.end()) {
                    elements.erase(it);
                }

                selectedElement = nullptr;
                Refresh();
            }
        }
    }

    void StartSimulation() {
        simulating = true;
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 1);

        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* io = dynamic_cast<InputOutput*>(element.get());
                if (io) {
                    io->SetValue(dis(gen) == 0);
                }
            }
        }
        UpdateCircuit();
        Refresh();
    }

    const std::vector<std::unique_ptr<CircuitElement>>& GetElements() const {
        return elements;
    }

    const std::vector<std::unique_ptr<Wire>>& GetWires() const {
        return wires;
    }

    void StopSimulation() {
        simulating = false;

        // 将所有输入元件的值设为0（false）
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                if (input) {
                    input->SetValue(false);
                }
            }
        }

        // 更新电路状态以反映所有输入为0的情况
        UpdateCircuit();
        Refresh();
    }

    // 更新整个电路状态
    void UpdateCircuit() {
        for (int i = 0; i < 5; ++i) {
            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    element->Update();
                }
            }

            for (auto& wire : wires) {
                wire->Update();
            }

            for (auto& element : elements) {
                if (element->GetType() >= TYPE_AND && element->GetType() <= TYPE_NOR) {
                    element->Update();
                }
            }

            for (auto& wire : wires) {
                wire->Update();
            }

            for (auto& element : elements) {
                if (element->GetType() == TYPE_OUTPUT) {
                    element->Update();
                }
            }
        }
    }

    void Clear() {
        elements.clear();
        wires.clear();
        selectedElement = nullptr;
        startPin = nullptr;
        autoPlaceMode = false;
        Refresh();
    }

    bool SaveCircuit(const wxString& filename) {
        wxFile file;
        if (file.Create(filename, true)) {
            wxString data;

            for (auto& element : elements) {
                element->Serialize(data);
                data += "\n";
            }

            for (auto& wire : wires) {
                wire->Serialize(data);
                data += "\n";
            }

            file.Write(data);
            file.Close();
            return true;
        }
        return false;
    }

    bool LoadCircuit(const wxString& filename) {
        wxFile file;
        if (file.Open(filename)) {
            wxString data;
            file.ReadAll(&data);
            file.Close();

            Clear();

            wxStringTokenizer lines(data, "\n");
            while (lines.HasMoreTokens()) {
                wxString line = lines.GetNextToken();
                wxStringTokenizer tokens(line, ",");

                if (tokens.HasMoreTokens()) {
                    wxString typeStr = tokens.GetNextToken();
                    if (typeStr == "wire") {
                        if (tokens.CountTokens() >= 2) {
                            wxString startId = tokens.GetNextToken();
                            wxString endId = tokens.GetNextToken();
                        }
                    }
                    else {
                        long typeVal;
                        typeStr.ToLong(&typeVal);
                        ElementType type = static_cast<ElementType>(typeVal);

                        if (type >= TYPE_AND && type <= TYPE_NOR) {
                            auto gate = std::make_unique<Gate>(type, 0, 0);
                            gate->Deserialize(line);
                            elements.push_back(std::move(gate));
                        }
                        else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
                            auto io = std::make_unique<InputOutput>(type, 0, 0);
                            io->Deserialize(line);
                            elements.push_back(std::move(io));
                        }
                    }
                }
            }

            Refresh();
            return true;
        }
        return false;
    }

    void ToggleGrid() {
        showGrid = !showGrid;
        Refresh();
    }

    void DeleteAll() {
        if (wxMessageBox("Are you sure you want to delete all elements?", "Confirm Delete All",
            wxYES_NO | wxICON_QUESTION, GetParent()) == wxYES) {
            elements.clear();
            wires.clear();
            selectedElement = nullptr;
            startPin = nullptr;
            autoPlaceMode = false;
            Refresh();
        }
    }

    void ZoomIn() {
        zoomLevel *= 1.2;
        Refresh();
    }

    void ZoomOut() {
        zoomLevel /= 1.2;
        Refresh();
    }

    void ResetZoom() {
        zoomLevel = 1.0;
        Refresh();
    }

    double GetZoomLevel() const { return zoomLevel; }

    CircuitElement* GetSelectedElement() const { return selectedElement; }

    void RenameSelectedElement(const wxString& newName) {
        if (selectedElement) {
            InputOutput* io = dynamic_cast<InputOutput*>(selectedElement);
            if (io) {
                io->SetName(newName);
                Refresh();
            }
        }
    }

    void ShowTruthTable();

    std::vector<InputOutput*> GetInputPins() const {
        std::vector<InputOutput*> inputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                inputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return inputs;
    }

    std::vector<InputOutput*> GetOutputPins() const {
        std::vector<InputOutput*> outputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_OUTPUT) {
                outputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return outputs;
    }

    bool IsInAutoPlaceMode() const { return autoPlaceMode; }
    ElementType GetAutoPlaceType() const { return autoPlaceType; }

private:
    // 原有私有成员和方法保持不变...
    // 修改 OnPaint 方法，在输入元件上显示更明显的值指示
    void OnPaint(wxPaintEvent& event) {
        wxAutoBufferedPaintDC dc(this);
        dc.Clear();

        dc.SetUserScale(zoomLevel, zoomLevel);

        if (showGrid) {
            dc.SetPen(wxPen(wxColour(220, 220, 220), 1));
            int width, height;
            GetClientSize(&width, &height);
            width /= zoomLevel;
            height /= zoomLevel;

            for (int x = 0; x < width; x += 20) {
                dc.DrawLine(x, 0, x, height);
            }
            for (int y = 0; y < height; y += 20) {
                dc.DrawLine(0, y, width, y);
            }
        }

        for (auto& wire : wires) {
            wire->Draw(dc);
        }

        for (auto& element : elements) {
            element->Draw(dc);
        }

        // 为输入元件添加点击提示
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxFont smallFont = dc.GetFont();
            smallFont.SetPointSize(7);
            dc.SetFont(smallFont);

            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                    if (input) {
                        wxRect bbox = element->GetBoundingBox();
                        wxString hint = "(Click to toggle)";
                        wxSize textSize = dc.GetTextExtent(hint);
                        dc.DrawText(hint,
                            bbox.GetLeft() + (bbox.GetWidth() - textSize.GetWidth()) / 2,
                            bbox.GetBottom() + 5);
                    }
                }
            }
        }

        if (wiringMode && startPin) {
            dc.SetPen(wxPen(*wxBLUE, 2, wxPENSTYLE_DOT));
            dc.DrawLine(startPin->GetX(), startPin->GetY(), lastMousePos.x, lastMousePos.y);
        }

        // 绘制自动放置预览
        if (autoPlaceMode && !simulating) {
            DrawAutoPlacePreview(dc, lastMousePos);
        }

        dc.SetUserScale(1.0, 1.0);
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxString toolText = GetToolName(currentTool);
            if (autoPlaceMode) {
                toolText += " - Click to place";
            }
            dc.DrawText(toolText, 10, 10);
            dc.DrawText(wxString::Format("Zoom: %.0f%%", zoomLevel * 100), 10, 30);
        }
        else {
            dc.SetTextForeground(*wxRED);
            dc.DrawText("SIMULATION RUNNING", 10, 10);
        }
    }

    void DrawAutoPlacePreview(wxDC& dc, const wxPoint& pos) {
        dc.SetPen(wxPen(*wxLIGHT_GREY, 1, wxPENSTYLE_DOT));
        dc.SetBrush(*wxTRANSPARENT_BRUSH);

        switch (autoPlaceType) {
        case TYPE_AND:
        case TYPE_OR:
        case TYPE_NOT:
        case TYPE_XOR:
        case TYPE_NAND:
        case TYPE_NOR:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);
            break;
        case TYPE_INPUT:
        case TYPE_OUTPUT:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);
            break;
        default:
            break;
        }
    }

    void OnLeftDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        pos.x /= zoomLevel;
        pos.y /= zoomLevel;
        lastMousePos = pos;

        // 如果是显示真值工具模式，优先处理输入元件点击
        if (currentTool == TYPE_TOGGLE_VALUE) {
            if (TryToggleInputElement(pos)) {
                Refresh();
                return;
            }
        }

        if (autoPlaceMode) {
            // 自动放置模式：直接创建元件
            CreateElementAtPosition(autoPlaceType, pos);
            return;
        }

        if (currentTool == TYPE_SELECT || currentTool == TYPE_TOGGLE_VALUE) {
            selectedElement = nullptr;
            for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
                if ((*it)->GetBoundingBox().Contains(pos)) {
                    selectedElement = it->get();
                    (*it)->SetSelected(true);

                    // 只有在选择工具模式下才能拖动
                    if (currentTool == TYPE_SELECT) {
                        dragStartPos = pos;
                        elementStartPos = wxPoint((*it)->GetX(), (*it)->GetY());
                    }
                    break;
                }
            }

            if (selectedElement == nullptr) {
                for (auto& element : elements) {
                    element->SetSelected(false);
                }
            }
        }
        else if (wiringMode) {
            Pin* pin = FindPinAt(pos);
            if (pin) {
                if (startPin == nullptr) {
                    startPin = pin;
                }
                else if (pin != startPin) {
                    if (startPin->IsInput() != pin->IsInput()) {
                        if (startPin->IsInput()) {
                            wires.push_back(std::make_unique<Wire>(pin, startPin));
                        }
                        else {
                            wires.push_back(std::make_unique<Wire>(startPin, pin));
                        }
                        UpdateCircuit();
                    }
                    startPin = nullptr;
                }
            }
            else if (startPin != nullptr) {
                startPin = nullptr;
            }
        }
        else {
            // 传统模式：点击创建元件
            CreateElementAtPosition(currentTool, pos);
        }

        Refresh();
    }

    // 新增方法：尝试切换输入元件的值
    bool TryToggleInputElement(const wxPoint& pos) {
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT && element->GetBoundingBox().Contains(pos)) {
                InputOutput* inputElement = dynamic_cast<InputOutput*>(element.get());
                if (inputElement) {
                    // 切换输入值（0变1，1变0）
                    inputElement->SetValue(!inputElement->GetValue());

                    // 更新电路状态
                    UpdateCircuit();

                    // 更新状态栏
                    wxWindow* topWindow = wxGetTopLevelParent(this);
                    if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
                        wxFrame* frame = static_cast<wxFrame*>(topWindow);
                        wxStatusBar* statusBar = frame->GetStatusBar();
                        if (statusBar) {
                            wxString state = inputElement->GetValue() ? "1" : "0";
                            wxString name = inputElement->GetDisplayName();
                            statusBar->SetStatusText(wxString::Format("%s toggled to %s", name, state));
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }
    void OnLeftUp(wxMouseEvent& event) {
        if (selectedElement) {
            selectedElement->SetSelected(false);
        }
    }

    // 修改 OnMouseMove 方法，只在选择工具模式下允许拖动
    void OnMouseMove(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        pos.x /= zoomLevel;
        pos.y /= zoomLevel;
        lastMousePos = pos;

        // 只有在选择工具模式下才能拖动元件
        if (event.Dragging() && selectedElement && currentTool == TYPE_SELECT) {
            int gridSize = 20;
            int x = elementStartPos.x + (pos.x - dragStartPos.x);
            int y = elementStartPos.y + (pos.y - dragStartPos.y);

            x = (x / gridSize) * gridSize;
            y = (y / gridSize) * gridSize;

            selectedElement->SetPosition(x, y);
            Refresh();
        }

        if (wiringMode && startPin) {
            Refresh();
        }

        // 在自动放置模式下实时刷新预览
        if (autoPlaceMode) {
            Refresh();
        }
    }


    void OnRightDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        pos.x /= zoomLevel;
        pos.y /= zoomLevel;

        CircuitElement* clickedElement = nullptr;
        for (auto& element : elements) {
            if (element->GetBoundingBox().Contains(pos)) {
                clickedElement = element.get();
                break;
            }
        }

        if (clickedElement) {
            if (selectedElement) {
                selectedElement->SetSelected(false);
            }
            selectedElement = clickedElement;
            selectedElement->SetSelected(true);

            wxMenu contextMenu;
            contextMenu.Append(wxID_DELETE, "Delete Element");
            contextMenu.Append(wxID_PROPERTIES, "Properties");

            PopupMenu(&contextMenu, event.GetPosition());
            Refresh();
        }
        else {
            for (auto& wire : wires) {
                if (wire->ContainsPoint(pos)) {
                    return;
                }
            }

            if (selectedElement) {
                selectedElement->SetSelected(false);
                selectedElement = nullptr;
                Refresh();
            }
        }
    }

    void OnMouseWheel(wxMouseEvent& event) {
        if (event.GetWheelRotation() > 0) {
            ZoomIn();
        }
        else {
            ZoomOut();
        }
    }

    void OnKeyDown(wxKeyEvent& event) {
        switch (event.GetKeyCode()) {
        case WXK_DELETE:
            DeleteSelectedElement();
            break;
        case WXK_ESCAPE:
            if (autoPlaceMode) {
                // 退出自动放置模式
                autoPlaceMode = false;
                SetCursor(wxCursor(wxCURSOR_ARROW));
                Refresh();
            }
            else if (wiringMode && startPin) {
                startPin = nullptr;
                Refresh();
            }
            break;
        case 'G':
            ToggleGrid();
            break;
        default:
            event.Skip();
            break;
        }
    }

    void OnSize(wxSizeEvent& event) {
        Refresh();
        event.Skip();
    }

    Pin* FindPinAt(const wxPoint& pos) {
        for (auto& element : elements) {
            for (auto pin : element->GetPins()) {
                int dx = pin->GetX() - pos.x;
                int dy = pin->GetY() - pos.y;
                if (std::sqrt(dx * dx + dy * dy) < 5) {
                    return pin;
                }
            }
        }
        return nullptr;
    }

    wxString GetToolName(ElementType tool) {
        switch (tool) {
        case TYPE_SELECT: return "Selection Tool";
        case TYPE_TOGGLE_VALUE: return "Toggle Value Tool";
        case TYPE_AND: return "AND Gate";
        case TYPE_OR: return "OR Gate";
        case TYPE_NOT: return "NOT Gate";
        case TYPE_XOR: return "XOR Gate";
        case TYPE_NAND: return "NAND Gate";
        case TYPE_NOR: return "NOR Gate";
        case TYPE_INPUT: return "Input Pin";
        case TYPE_OUTPUT: return "Output Pin";
        case TYPE_WIRE: return "Wire Tool";
        default: return "Unknown Tool";
        }
    }
    ElementType currentTool;
    bool wiringMode;
    bool simulating;
    bool showGrid;
    double zoomLevel;
    CircuitElement* selectedElement;
    Pin* startPin;
    wxPoint lastMousePos;
    wxPoint dragStartPos;
    wxPoint elementStartPos;

    bool autoPlaceMode;
    ElementType autoPlaceType;

    std::vector<std::unique_ptr<CircuitElement>> elements;
    std::vector<std::unique_ptr<Wire>> wires;

    // 原有事件处理方法保持不变...
    // [原有代码保持不变]
};

// 元件树控件类 - 修改以包含时序元件
class ElementTreeCtrl : public wxTreeCtrl {
public:
    ElementTreeCtrl(wxWindow* parent, CircuitCanvas* canvas)
        : wxTreeCtrl(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize,
            wxTR_DEFAULT_STYLE | wxTR_HIDE_ROOT | wxTR_SINGLE),
        canvas(canvas) {

        // 创建根节点（隐藏）
        root = AddRoot("Circuit Elements");

        // 创建分类节点
        gatesNode = AppendItem(root, "Logic Gates");
        sequentialNode = AppendItem(root, "Sequential Elements"); // 新增时序元件分类
        ioNode = AppendItem(root, "Input/Output");
        wiresNode = AppendItem(root, "Wires");

        // 初始化工具映射
        InitializeToolMap();

        // 展开所有节点
        ExpandAll();

        // 绑定事件
        Bind(wxEVT_TREE_SEL_CHANGED, &ElementTreeCtrl::OnSelectionChanged, this);
        Bind(wxEVT_TREE_ITEM_ACTIVATED, &ElementTreeCtrl::OnItemActivated, this);
    }

    void UpdateTree() {
        // 清除现有元素节点
        DeleteChildren(gatesNode);
        DeleteChildren(sequentialNode); // 新增
        DeleteChildren(ioNode);
        DeleteChildren(wiresNode);

        // 添加逻辑门工具项
        wxTreeItemId andItem = AppendItem(gatesNode, "AND Gate");
        toolMap[andItem] = TYPE_AND;

        wxTreeItemId orItem = AppendItem(gatesNode, "OR Gate");
        toolMap[orItem] = TYPE_OR;

        wxTreeItemId notItem = AppendItem(gatesNode, "NOT Gate");
        toolMap[notItem] = TYPE_NOT;

        wxTreeItemId xorItem = AppendItem(gatesNode, "XOR Gate");
        toolMap[xorItem] = TYPE_XOR;

        wxTreeItemId nandItem = AppendItem(gatesNode, "NAND Gate");
        toolMap[nandItem] = TYPE_NAND;

        wxTreeItemId norItem = AppendItem(gatesNode, "NOR Gate");
        toolMap[norItem] = TYPE_NOR;

        // 添加时序元件工具项
        wxTreeItemId clockItem = AppendItem(sequentialNode, "Clock");
        toolMap[clockItem] = TYPE_CLOCK;

        wxTreeItemId dffItem = AppendItem(sequentialNode, "D Flip-Flop");
        toolMap[dffItem] = TYPE_D_FLIPFLOP;

        wxTreeItemId jkffItem = AppendItem(sequentialNode, "JK Flip-Flop");
        toolMap[jkffItem] = TYPE_JK_FLIPFLOP;

        wxTreeItemId tffItem = AppendItem(sequentialNode, "T Flip-Flop");
        toolMap[tffItem] = TYPE_T_FLIPFLOP;

        wxTreeItemId regItem = AppendItem(sequentialNode, "4-bit Register");
        toolMap[regItem] = TYPE_REGISTER;

        // 添加输入输出工具项
        wxTreeItemId inputItem = AppendItem(ioNode, "Input Pin");
        toolMap[inputItem] = TYPE_INPUT;

        wxTreeItemId outputItem = AppendItem(ioNode, "Output Pin");
        toolMap[outputItem] = TYPE_OUTPUT;

        // 添加导线工具项
        wxTreeItemId wireItem = AppendItem(wiresNode, "Wire Tool");
        toolMap[wireItem] = TYPE_WIRE;

        // 添加选择工具项
        wxTreeItemId selectItem = AppendItem(wiresNode, "Selection Tool");
        toolMap[selectItem] = TYPE_SELECT;

        // 添加实际电路中的元件
        const auto& elements = canvas->GetElements();
        for (const auto& element : elements) {
            wxTreeItemId parentNode;
            switch (element->GetType()) {
            case TYPE_AND:
            case TYPE_OR:
            case TYPE_NOT:
            case TYPE_XOR:
            case TYPE_NAND:
            case TYPE_NOR:
                parentNode = gatesNode;
                break;
            case TYPE_CLOCK:
            case TYPE_D_FLIPFLOP:
            case TYPE_JK_FLIPFLOP:
            case TYPE_T_FLIPFLOP:
            case TYPE_REGISTER:
                parentNode = sequentialNode;
                break;
            case TYPE_INPUT:
            case TYPE_OUTPUT:
                parentNode = ioNode;
                break;
            default:
                continue;
            }

            wxString itemText = element->GetDisplayName() +
                wxString::Format(" (X:%d, Y:%d)",
                    element->GetX(), element->GetY());
            wxTreeItemId itemId = AppendItem(parentNode, itemText);
            elementMap[itemId] = element.get();
        }

        // 添加导线
        const auto& wires = canvas->GetWires();
        for (size_t i = 0; i < wires.size(); ++i) {
            wxString wireText = wxString::Format("Wire %zu", i + 1);
            wxTreeItemId itemId = AppendItem(wiresNode, wireText);
            wireMap[itemId] = wires[i].get();
        }

        ExpandAll();
    }

private:


    void InitializeToolMap() {
        // 这个映射将在 UpdateTree 中填充
    }

    void OnSelectionChanged(wxTreeEvent& event) {
        wxTreeItemId itemId = event.GetItem();
        if (itemId.IsOk() && toolMap.find(itemId) != toolMap.end()) {
            ElementType selectedTool = toolMap[itemId];
            canvas->SetCurrentTool(selectedTool);

            // 更新状态栏显示（通过主窗口）
            wxWindow* topWindow = wxGetTopLevelParent(this);
            if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
                wxFrame* frame = static_cast<wxFrame*>(topWindow);
                wxStatusBar* statusBar = frame->GetStatusBar();
                if (statusBar) {
                    wxString toolName = GetToolName(selectedTool);
                    statusBar->SetStatusText(wxString::Format("%s selected from tree", toolName));
                }
            }
        }
        event.Skip();
    }

    void OnItemActivated(wxTreeEvent& event) {
        wxTreeItemId itemId = event.GetItem();
        if (itemId.IsOk() && toolMap.find(itemId) != toolMap.end()) {
            ElementType selectedTool = toolMap[itemId];
            canvas->SetCurrentTool(selectedTool);

            // 在画布上自动放置一个元件（如果是元件工具）
            if (selectedTool != TYPE_SELECT && selectedTool != TYPE_WIRE) {
                // 获取画布中心位置
                wxSize canvasSize = canvas->GetClientSize();
                wxPoint centerPos(canvasSize.GetWidth() / 2, canvasSize.GetHeight() / 2);

                // 创建新元件（这里需要扩展 CircuitCanvas 的功能）
                canvas->CreateElementAtPosition(selectedTool, centerPos);
            }
        }
        event.Skip();
    }
    wxString GetToolName(ElementType tool) {
        // 添加时序元件的名称
        switch (tool) {
        case TYPE_SELECT: return "Selection Tool";
        case TYPE_AND: return "AND Gate";
        case TYPE_OR: return "OR Gate";
        case TYPE_NOT: return "NOT Gate";
        case TYPE_XOR: return "XOR Gate";
        case TYPE_NAND: return "NAND Gate";
        case TYPE_NOR: return "NOR Gate";
        case TYPE_CLOCK: return "Clock";
        case TYPE_D_FLIPFLOP: return "D Flip-Flop";
        case TYPE_JK_FLIPFLOP: return "JK Flip-Flop";
        case TYPE_T_FLIPFLOP: return "T Flip-Flop";
        case TYPE_REGISTER: return "4-bit Register";
        case TYPE_INPUT: return "Input Pin";
        case TYPE_OUTPUT: return "Output Pin";
        case TYPE_WIRE: return "Wire Tool";
        default: return "Unknown Tool";
        }
    }   
    // 原有私有成员和方法保持不变...
    std::map<wxTreeItemId, CircuitElement*> elementMap;
    std::map<wxTreeItemId, Wire*> wireMap;
    wxTreeItemId root;
    wxTreeItemId gatesNode;
    wxTreeItemId sequentialNode; // 新增
    wxTreeItemId ioNode;
    wxTreeItemId wiresNode;
    CircuitCanvas* canvas;
    std::map<wxTreeItemId, ElementType> toolMap;
};

// 真值表对话框
class TruthTableDialog : public wxDialog {
public:
    TruthTableDialog(wxWindow* parent, CircuitCanvas* canvas)
        : wxDialog(parent, wxID_ANY, "Truth Table", wxDefaultPosition, wxSize(600, 400)), canvas(canvas) {

        wxBoxSizer* mainSizer = new wxBoxSizer(wxVERTICAL);

        // 创建网格
        grid = new wxGrid(this, wxID_ANY);
        mainSizer->Add(grid, 1, wxEXPAND | wxALL, 5);

        // 按钮
        wxBoxSizer* buttonSizer = new wxBoxSizer(wxHORIZONTAL);
        buttonSizer->Add(new wxButton(this, wxID_CLOSE, "Close"), 0, wxALL, 5);
        buttonSizer->Add(new wxButton(this, wxID_REFRESH, "Refresh"), 0, wxALL, 5);

        mainSizer->Add(buttonSizer, 0, wxALIGN_CENTER | wxALL, 5);

        SetSizer(mainSizer);

        // 绑定事件
        Bind(wxEVT_BUTTON, &TruthTableDialog::OnClose, this, wxID_CLOSE);
        Bind(wxEVT_BUTTON, &TruthTableDialog::OnRefresh, this, wxID_REFRESH);

        GenerateTruthTable();
    }

    void GenerateTruthTable() {
        // 从画布获取实际的输入输出引脚
        std::vector<InputOutput*> inputs = canvas->GetInputPins();
        std::vector<InputOutput*> outputs = canvas->GetOutputPins();

        int numInputs = static_cast<int>(inputs.size());
        int numOutputs = static_cast<int>(outputs.size());

        // 清除现有网格
        if (grid->GetNumberRows() > 0) {
            grid->DeleteRows(0, grid->GetNumberRows());
        }
        if (grid->GetNumberCols() > 0) {
            grid->DeleteCols(0, grid->GetNumberCols());
        }

        if (numInputs == 0 && numOutputs == 0) {
            // 没有 IO，显示提示
            grid->CreateGrid(1, 1);
            grid->SetCellValue(0, 0, "No inputs/outputs");
            grid->AutoSize();
            return;
        }

        int rows = (numInputs > 0) ? (1 << numInputs) : 1;
        int cols = numInputs + numOutputs;
        if (cols == 0) cols = 1; // 防御

        grid->CreateGrid(rows, cols);

        // 设置列标签
        for (int i = 0; i < numInputs; ++i) {
            grid->SetColLabelValue(i, wxString::Format("Input %d", i + 1));
        }
        for (int i = 0; i < numOutputs; ++i) {
            grid->SetColLabelValue(numInputs + i, wxString::Format("Output %d", i + 1));
        }

        // 对每个输入组合，设置输入 -> 运行画布仿真 -> 读取输出填表
        for (int row = 0; row < rows; ++row) {
            // 设置输入值（高位到低位对应 Input1..InputN）
            for (int i = 0; i < numInputs; ++i) {
                bool bit = ((row >> (numInputs - i - 1)) & 1) != 0;
                // 将值写入 InputOutput 的 value（它的 Update() 会把值写到 pin）
                inputs[i]->SetValue(bit);
                grid->SetCellValue(row, i, bit ? "1" : "0");
                grid->SetCellAlignment(row, i, wxALIGN_CENTER, wxALIGN_CENTER);
            }

            // 让画布进行一次完整传播（会调用每个 element->Update() 与 wire->Update()）
            canvas->UpdateCircuit();

            // 读取输出引脚的值
            for (int j = 0; j < numOutputs; ++j) {
                bool outVal = outputs[j]->GetValue();
                grid->SetCellValue(row, numInputs + j, outVal ? "1" : "0");
                grid->SetCellAlignment(row, numInputs + j, wxALIGN_CENTER, wxALIGN_CENTER);
            }
        }

        grid->AutoSize();
    }


private:
    void OnClose(wxCommandEvent& event) {
        Close();
    }

    void OnRefresh(wxCommandEvent& event) {
        GenerateTruthTable();
    }

    wxGrid* grid;
    CircuitCanvas* canvas;
};

void CircuitCanvas::ShowTruthTable() {
    TruthTableDialog dialog(GetParent(), this);
    dialog.ShowModal();
}

// 属性面板类
class PropertiesPanel : public wxPanel {
public:
    PropertiesPanel(wxWindow* parent, CircuitCanvas* canvas)
        : wxPanel(parent), canvas(canvas) {

        wxBoxSizer* sizer = new wxBoxSizer(wxVERTICAL);

        pg = new wxPropertyGrid(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
            wxPG_DEFAULT_STYLE | wxPG_BOLD_MODIFIED);
        sizer->Add(pg, 1, wxEXPAND);

        SetSizer(sizer);

        // 绑定事件
        pg->Bind(wxEVT_PG_CHANGED, &PropertiesPanel::OnPropertyChanged, this);

        canvas->Bind(wxEVT_LEFT_DOWN, &PropertiesPanel::OnCanvasSelectionChange, this);
    }

    void UpdateProperties() {
        pg->Clear();

        CircuitElement* selected = canvas->GetSelectedElement();
        if (selected) {
            selected->GetProperties(pg);
        }
        else {
            pg->Append(new wxStringProperty("No Selection", "None", "Select an element to edit properties"));
        }
    }

private:
    void OnPropertyChanged(wxPropertyGridEvent& event) {
        CircuitElement* selected = canvas->GetSelectedElement();
        if (selected) {
            selected->SetProperties(pg);
            canvas->Refresh();
        }
    }

    void OnCanvasSelectionChange(wxMouseEvent& event) {
        UpdateProperties();
        event.Skip();
    }

    wxPropertyGrid* pg;
    CircuitCanvas* canvas;
};

// 主菜单类 - 修改以包含时序元件工具
class MainMenu : public wxMenuBar {
public:
    MainMenu(CircuitCanvas* canvas) : canvas(canvas) {
        // 文件菜单、编辑菜单、模拟菜单、视图菜单保持不变...
                // 文件菜单
        wxMenu* fileMenu = new wxMenu();
        fileMenu->Append(wxID_NEW, "&New\tCtrl+N", "Create a new circuit");
        fileMenu->Append(wxID_OPEN, "&Open\tCtrl+O", "Open a circuit file");
        fileMenu->Append(wxID_SAVE, "&Save\tCtrl+S", "Save the circuit");
        fileMenu->Append(wxID_SAVEAS, "Save &As...", "Save the circuit with a new name");
        fileMenu->AppendSeparator();
        fileMenu->Append(wxID_EXIT, "E&xit\tAlt+F4", "Exit the application");

        // 编辑菜单
        wxMenu* editMenu = new wxMenu();
        editMenu->Append(wxID_UNDO, "&Undo\tCtrl+Z", "Undo the last action");
        editMenu->Append(wxID_REDO, "&Redo\tCtrl+Y", "Redo the undone action");
        editMenu->AppendSeparator();
        editMenu->Append(wxID_CUT, "Cu&t\tCtrl+X", "Cut the selection");
        editMenu->Append(wxID_COPY, "&Copy\tCtrl+C", "Copy the selection");
        editMenu->Append(wxID_PASTE, "&Paste\tCtrl+V", "Paste from clipboard");
        editMenu->AppendSeparator();
        editMenu->Append(wxID_DELETE, "&Delete\tDel", "Delete the selection");
        editMenu->Append(ID_DELETE_ALL, "Delete &All", "Delete all elements");
        editMenu->Append(wxID_SELECTALL, "Select &All\tCtrl+A", "Select all elements");
        editMenu->AppendSeparator();
        editMenu->Append(ID_RENAME, "Re&name\tF2", "Rename selected element");

        // 模拟菜单
        wxMenu* simMenu = new wxMenu();
        simMenu->Append(ID_START_SIM, "&Start Simulation\tF5", "Start circuit simulation");
        simMenu->Append(ID_STOP_SIM, "S&top Simulation\tF6", "Stop circuit simulation");
        simMenu->AppendSeparator();
        simMenu->Append(ID_RESET, "&Reset", "Reset the simulation");
        simMenu->Append(ID_STEP, "&Step\tF7", "Single simulation step");
        simMenu->AppendSeparator();
        simMenu->Append(ID_TRUTH_TABLE, "&Truth Table\tT", "Show truth table");

        // 视图菜单
        wxMenu* viewMenu = new wxMenu();
        viewMenu->Append(ID_ZOOM_IN, "Zoom &In\tCtrl++", "Zoom in");
        viewMenu->Append(ID_ZOOM_OUT, "Zoom &Out\tCtrl+-", "Zoom out");
        viewMenu->Append(ID_ZOOM_RESET, "Zoom &Reset\tCtrl+0", "Reset zoom to 100%");
        viewMenu->AppendSeparator();
        viewMenu->AppendCheckItem(ID_SHOW_GRID, "Show &Grid\tG", "Toggle grid display");
        viewMenu->Check(ID_SHOW_GRID, true);
        viewMenu->Append(ID_TOGGLE_GRID, "Toggle &Grid\tG", "Toggle grid display");
     
          // 工具菜单    - 添加时序元件
        wxMenu* toolsMenu = new wxMenu();
        toolsMenu->AppendRadioItem(ID_TOOL_SELECT, "&Select Tool\tS", "Selection tool");
        toolsMenu->AppendRadioItem(ID_TOOL_TOGGLE_VALUE, "Toggle &Value Tool\tV", "Toggle input values tool");
        toolsMenu->AppendRadioItem(ID_TOOL_WIRE, "&Wire Tool\tW", "Wire connection tool");
        toolsMenu->AppendRadioItem(ID_TOOL_SELECT, "&Select Tool\tS", "Selection tool");
        toolsMenu->AppendSeparator();
        toolsMenu->AppendRadioItem(ID_TOOL_AND, "&AND Gate\tA", "AND Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_OR, "&OR Gate\tO", "OR Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NOT, "&NOT Gate\tN", "NOT Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_XOR, "&XOR Gate\tX", "XOR Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NAND, "&NAND Gate", "NAND Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NOR, "N&OR Gate", "NOR Gate tool");
        toolsMenu->AppendSeparator();
        toolsMenu->AppendRadioItem(ID_TOOL_INPUT, "&Input Pin\tI", "Input Pin tool");
        toolsMenu->AppendRadioItem(ID_TOOL_OUTPUT, "&Output Pin\tP", "Output Pin tool");    
        toolsMenu->AppendRadioItem(ID_TOOL_SELECT, "&Select Tool\tS", "Selection tool");
        toolsMenu->AppendSeparator();

        // 组合逻辑元件
        toolsMenu->AppendRadioItem(ID_TOOL_AND, "&AND Gate\tA", "AND Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_OR, "&OR Gate\tO", "OR Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NOT, "&NOT Gate\tN", "NOT Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_XOR, "&XOR Gate\tX", "XOR Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NAND, "&NAND Gate", "NAND Gate tool");
        toolsMenu->AppendRadioItem(ID_TOOL_NOR, "N&OR Gate", "NOR Gate tool");
        toolsMenu->AppendSeparator();

        // 时序逻辑元件
        toolsMenu->AppendRadioItem(ID_TOOL_CLOCK, "C&lock Signal\tC", "Clock signal tool");
        toolsMenu->AppendRadioItem(ID_TOOL_D_FLIPFLOP, "&D Flip-Flop\tD", "D Flip-Flop tool");
        toolsMenu->AppendRadioItem(ID_TOOL_JK_FLIPFLOP, "&JK Flip-Flop\tJ", "JK Flip-Flop tool");
        toolsMenu->AppendRadioItem(ID_TOOL_T_FLIPFLOP, "&T Flip-Flop\tT", "T Flip-Flop tool");
        toolsMenu->AppendRadioItem(ID_TOOL_REGISTER, "&Register\tR", "4-bit Register tool");
        toolsMenu->AppendSeparator();

        // 输入输出
        toolsMenu->AppendRadioItem(ID_TOOL_INPUT, "&Input Pin\tI", "Input Pin tool");
        toolsMenu->AppendRadioItem(ID_TOOL_OUTPUT, "&Output Pin\tP", "Output Pin tool");



        // 帮助菜单
        wxMenu* helpMenu = new wxMenu();
        helpMenu->Append(wxID_ABOUT, "&About", "About this application");
        helpMenu->Append(wxID_HELP, "&Help\tF1", "Show help documentation");
        // 添加到菜单栏...
        Append(fileMenu, "&File");
        Append(editMenu, "&Edit");
        Append(simMenu, "&Simulation");
        Append(viewMenu, "&View");
        Append(toolsMenu, "&Tools");
        Append(helpMenu, "&Help");
    }

    enum {
        ID_START_SIM = wxID_HIGHEST + 1,
        ID_STOP_SIM,
        ID_RESET,
        ID_STEP,
        ID_ZOOM_IN,
        ID_ZOOM_OUT,
        ID_ZOOM_RESET,
        ID_SHOW_GRID,
        ID_TOGGLE_GRID,
        ID_TOOL_SELECT,
        ID_TOOL_TOGGLE_VALUE,
        ID_TOOL_WIRE,
        ID_TOOL_AND,
        ID_TOOL_OR,
        ID_TOOL_NOT,
        ID_TOOL_XOR,
        ID_TOOL_NAND,
        ID_TOOL_NOR,
        ID_TOOL_CLOCK,        // 新增
        ID_TOOL_D_FLIPFLOP,   // 新增
        ID_TOOL_JK_FLIPFLOP,  // 新增
        ID_TOOL_T_FLIPFLOP,   // 新增
        ID_TOOL_REGISTER,     // 新增
        ID_TOOL_INPUT,
        ID_TOOL_OUTPUT,
        ID_RENAME,
        ID_DELETE_ALL,
        ID_TRUTH_TABLE
    };

private:
    CircuitCanvas* canvas;
};

// 工具栏类 - 修改以包含时序元件工具
class MainToolbar : public wxToolBar {
public:
    MainToolbar(wxWindow* parent, CircuitCanvas* canvas) : wxToolBar(parent, wxID_ANY), canvas(canvas) {
        // 文件操作工具
        AddTool(wxID_NEW, "New", wxArtProvider::GetBitmap(wxART_NEW), "New Circuit");
        AddTool(wxID_OPEN, "Open", wxArtProvider::GetBitmap(wxART_FILE_OPEN), "Open Circuit");
        AddTool(wxID_SAVE, "Save", wxArtProvider::GetBitmap(wxART_FILE_SAVE), "Save Circuit");
     

        // 基本工具

        AddTool(ID_SELECT, "Select", wxBitmap(wxT("mouse.png"), wxBITMAP_TYPE_PNG), "Select", wxITEM_RADIO);
        AddTool(ID_TOGGLE_VALUE, "Toggle Value", wxArtProvider::GetBitmap(wxART_TIP), "Toggle Value Tool", wxITEM_RADIO);
        AddTool(ID_WIRE, "Wire", wxArtProvider::GetBitmap(wxART_PLUS), "Wire Tool", wxITEM_RADIO);


        // 组合逻辑门
        AddTool(ID_AND, "AND", wxBitmap(wxT("AND.png"), wxBITMAP_TYPE_PNG), "AND Gate", wxITEM_RADIO);
        AddTool(ID_OR, "OR", wxBitmap(wxT("OR.png"), wxBITMAP_TYPE_PNG), "OR Gate", wxITEM_RADIO);
        AddTool(ID_NOT, "NOT", wxBitmap(wxT("NOT.png"), wxBITMAP_TYPE_PNG), "NOT Gate", wxITEM_RADIO);
        AddTool(ID_XOR, "XOR", wxBitmap(wxT("XOR.png"), wxBITMAP_TYPE_PNG), "XOR Gate", wxITEM_RADIO);
        AddTool(ID_NAND, "NAND", wxBitmap(wxT("NAND.png"), wxBITMAP_TYPE_PNG), "NAND Gate", wxITEM_RADIO);
        AddTool(ID_NOR, "NOR", wxBitmap(wxT("NOR.png"), wxBITMAP_TYPE_PNG), "NOR Gate", wxITEM_RADIO);

        // 时序逻辑元件
        AddTool(ID_CLOCK, "Clock", wxBitmap(wxT("Clock.png"), wxBITMAP_TYPE_PNG), "Clock Signal", wxITEM_RADIO);
        AddTool(ID_D_FLIPFLOP, "D-FF", wxArtProvider::GetBitmap(wxART_GO_HOME), "D Flip-Flop", wxITEM_RADIO);
        AddTool(ID_JK_FLIPFLOP, "JK-FF", wxArtProvider::GetBitmap(wxART_GO_HOME), "JK Flip-Flop", wxITEM_RADIO);
        AddTool(ID_T_FLIPFLOP, "T-FF", wxArtProvider::GetBitmap(wxART_GO_HOME), "T Flip-Flop", wxITEM_RADIO);
        AddTool(ID_REGISTER, "Register", wxArtProvider::GetBitmap(wxART_GO_HOME), "4-bit Register", wxITEM_RADIO);


        // 输入输出
        AddTool(ID_INPUT, "Input", wxBitmap(wxT("INPUT.png"), wxBITMAP_TYPE_PNG), "Input Pin", wxITEM_RADIO);
        AddTool(ID_OUTPUT, "Output", wxBitmap(wxT("OUTPUT.png"), wxBITMAP_TYPE_PNG), "Output Pin", wxITEM_RADIO);

        // 仿真控制
        AddTool(ID_START_SIM, "Start", wxArtProvider::GetBitmap(wxART_GO_FORWARD), "Start Simulation");
        AddTool(ID_STOP_SIM, "Stop", wxArtProvider::GetBitmap(wxART_STOP), "Stop Simulation");
        AddTool(ID_STEP, "Step", wxArtProvider::GetBitmap(wxART_GO_DOWN), "Single Step");
        AddTool(ID_TRUTH_TABLE, "Truth Table", wxArtProvider::GetBitmap(wxART_LIST_VIEW), "Show Truth Table");


        // 删除操作
        AddTool(wxID_DELETE, "Delete", wxArtProvider::GetBitmap(wxART_DELETE), "Delete Selected Element");
        AddTool(ID_DELETE_ALL, "Delete All", wxArtProvider::GetBitmap(wxART_DELETE), "Delete All Elements");

        Realize();
        ToggleTool(ID_SELECT, true);

        // 绑定事件
        Bind(wxEVT_TOOL, &MainToolbar::OnToolClicked, this);
    }

    enum {
        ID_SELECT = MainMenu::ID_TRUTH_TABLE + 1,
        ID_TOGGLE_VALUE,
        ID_WIRE,
        ID_AND,
        ID_OR,
        ID_NOT,
        ID_XOR,
        ID_NAND,
        ID_NOR,
        ID_CLOCK,           // 新增
        ID_D_FLIPFLOP,      // 新增
        ID_JK_FLIPFLOP,     // 新增
        ID_T_FLIPFLOP,      // 新增
        ID_REGISTER,        // 新增
        ID_INPUT,
        ID_OUTPUT,
        ID_START_SIM,
        ID_STOP_SIM,
        ID_STEP,
        ID_DELETE_ALL,
        ID_TRUTH_TABLE,
        ID_TOGGLE_TREE
    };

private:
    void OnToolClicked(wxCommandEvent& event) {
        int id = event.GetId();
        ElementType toolType = TYPE_SELECT;

        switch (id) {
        case ID_SELECT:
            toolType = TYPE_SELECT;
            break;
        case ID_TOGGLE_VALUE:
            toolType = TYPE_TOGGLE_VALUE;
            break;
        case ID_WIRE:
            toolType = TYPE_WIRE;
            break;
        case ID_AND:
            toolType = TYPE_AND;
            break;
        case ID_OR:
            toolType = TYPE_OR;
            break;
        case ID_NOT:
            toolType = TYPE_NOT;
            break;
        case ID_XOR:
            toolType = TYPE_XOR;
            break;
        case ID_NAND:
            toolType = TYPE_NAND;
            break;
        case ID_NOR:
            toolType = TYPE_NOR;
            break;
        case ID_CLOCK:
            toolType = TYPE_CLOCK;
            break;
        case ID_D_FLIPFLOP:
            toolType = TYPE_D_FLIPFLOP;
            break;
        case ID_JK_FLIPFLOP:
            toolType = TYPE_JK_FLIPFLOP;
            break;
        case ID_T_FLIPFLOP:
            toolType = TYPE_T_FLIPFLOP;
            break;
        case ID_REGISTER:
            toolType = TYPE_REGISTER;
            break;
        case ID_INPUT:
            toolType = TYPE_INPUT;
            break;
        case ID_OUTPUT:
            toolType = TYPE_OUTPUT;
            break;
        default:
            event.Skip();
            return;
        }

        // 设置自动放置模式
        if (toolType != TYPE_SELECT && toolType != TYPE_WIRE && toolType != TYPE_TOGGLE_VALUE) {
            canvas->SetAutoPlaceMode(toolType);
        }
        else {
            canvas->SetCurrentTool(toolType);
        }

        // 更新工具栏状态
        for (int toolId = ID_SELECT; toolId <= ID_OUTPUT; toolId++) {
            ToggleTool(toolId, toolId == id);
        }
    }

    CircuitCanvas* canvas;
};

// 主窗口类和其他类保持不变...
// [原有代码保持不变]
// 主窗口类
class MainFrame : public wxFrame {
public:
    MainFrame() : wxFrame(nullptr, wxID_ANY, "Logisim-like Circuit Simulator",
        wxDefaultPosition, wxSize(1200, 800)) {

        // 创建主分割窗口
        mainSplitter = new wxSplitterWindow(this, wxID_ANY);

        // 创建左侧分割窗口（树控件和画布）
        leftSplitter = new wxSplitterWindow(mainSplitter, wxID_ANY);

        // 创建画布
        canvas = new CircuitCanvas(leftSplitter);

        // 创建元件树控件（现在传递正确的 canvas 引用）
        elementTree = new ElementTreeCtrl(leftSplitter, canvas);

        // 设置左侧分割窗口
        leftSplitter->SplitVertically(elementTree, canvas, 200);
        leftSplitter->SetMinimumPaneSize(100);

        // 创建属性面板
        propertiesPanel = new PropertiesPanel(mainSplitter, canvas);

        // 设置主分割窗口
        mainSplitter->SplitVertically(leftSplitter, propertiesPanel, 800);
        mainSplitter->SetMinimumPaneSize(200);

        // 创建菜单栏和工具栏
        menuBar = new MainMenu(canvas);
        SetMenuBar(menuBar);

        toolBar = new MainToolbar(this, canvas);
        SetToolBar(toolBar);

        // 创建状态栏
        CreateStatusBar();
        GetStatusBar()->SetStatusText("Ready");

        // 绑定事件
        Bind(wxEVT_MENU, &MainFrame::OnMenuEvent, this);
        Bind(wxEVT_TOOL, &MainFrame::OnToolEvent, this);
        Bind(wxEVT_CLOSE_WINDOW, &MainFrame::OnClose, this);

        // 设置最小大小
        SetMinClientSize(wxSize(800, 600));

        // 初始化属性面板
        propertiesPanel->UpdateProperties();

        // 初始化元件树
        elementTree->UpdateTree();
    }

private:
    MainMenu* menuBar;
    MainToolbar* toolBar;
    CircuitCanvas* canvas;
    PropertiesPanel* propertiesPanel;
    wxSplitterWindow* splitter;
    wxString currentFilename;
    ElementTreeCtrl* elementTree;
    wxSplitterWindow* mainSplitter;
    wxSplitterWindow* leftSplitter;
    bool treeVisible = true;

    void OnMenuEvent(wxCommandEvent& event) {
        int id = event.GetId();

        switch (id) {
            // 在 OnMenuEvent 方法中添加
        case MainMenu::ID_TOOL_TOGGLE_VALUE:
            canvas->SetCurrentTool(TYPE_TOGGLE_VALUE);
            GetStatusBar()->SetStatusText("Toggle Value tool selected - click on input pins to change values");
            break;
        case ID_TOGGLE_TREE:
            ToggleElementTree();
            break;
        case wxID_NEW:
            if (ConfirmSave()) {
                canvas->Clear();
                currentFilename = "";
                SetTitle("Logisim-like Circuit Simulator - New Circuit");
                GetStatusBar()->SetStatusText("New circuit created");
                propertiesPanel->UpdateProperties();
            }
            break;

        case wxID_OPEN: {
            if (ConfirmSave()) {
                wxFileDialog openFileDialog(this, "Open Circuit File", "", "",
                    "Circuit files (*.circ)|*.circ", wxFD_OPEN | wxFD_FILE_MUST_EXIST);

                if (openFileDialog.ShowModal() == wxID_CANCEL)
                    return;

                currentFilename = openFileDialog.GetPath();
                if (canvas->LoadCircuit(currentFilename)) {
                    wxFileName fn(currentFilename);
                    SetTitle(wxString::Format("Logisim-like Circuit Simulator - %s", fn.GetFullName()));
                    GetStatusBar()->SetStatusText("Circuit loaded successfully");
                    propertiesPanel->UpdateProperties();
                }
                else {
                    wxMessageBox("Failed to load circuit file", "Error", wxOK | wxICON_ERROR, this);
                }
            }
            break;
        }

        case wxID_SAVE:
            if (currentFilename.empty()) {
                OnSaveAs(event);
            }
            else {
                if (canvas->SaveCircuit(currentFilename)) {
                    GetStatusBar()->SetStatusText("Circuit saved successfully");
                }
                else {
                    wxMessageBox("Failed to save circuit file", "Error", wxOK | wxICON_ERROR, this);
                }
            }
            break;

        case wxID_SAVEAS:
            OnSaveAs(event);
            break;

        case wxID_EXIT:
            Close(true);
            break;

        case MainMenu::ID_START_SIM:
            canvas->StartSimulation();
            GetStatusBar()->SetStatusText("Simulation running");
            break;

        case MainMenu::ID_STOP_SIM:
            canvas->StopSimulation();
            GetStatusBar()->SetStatusText("Simulation stopped");
            break;

        case MainMenu::ID_STEP:
            canvas->UpdateCircuit();
            canvas->Refresh();
            GetStatusBar()->SetStatusText("Simulation step executed");
            break;

        case MainMenu::ID_ZOOM_IN:
            canvas->ZoomIn();
            GetStatusBar()->SetStatusText(wxString::Format("Zoom: %.0f%%", canvas->GetZoomLevel() * 100));
            break;

        case MainMenu::ID_ZOOM_OUT:
            canvas->ZoomOut();
            GetStatusBar()->SetStatusText(wxString::Format("Zoom: %.0f%%", canvas->GetZoomLevel() * 100));
            break;

        case MainMenu::ID_ZOOM_RESET:
            canvas->ResetZoom();
            GetStatusBar()->SetStatusText("Zoom reset to 100%");
            break;

        case MainMenu::ID_TOGGLE_GRID:
            canvas->ToggleGrid();
            GetStatusBar()->SetStatusText("Grid toggled");
            break;

        case MainMenu::ID_TOOL_SELECT:
            canvas->SetCurrentTool(TYPE_SELECT);
            GetStatusBar()->SetStatusText("Selection tool activated");
            break;

        case MainMenu::ID_TOOL_WIRE:
            canvas->SetCurrentTool(TYPE_WIRE);
            GetStatusBar()->SetStatusText("Wire tool selected - click on pins to connect");
            break;

        case MainMenu::ID_TOOL_AND:
            canvas->SetCurrentTool(TYPE_AND);
            GetStatusBar()->SetStatusText("AND Gate tool selected");
            break;

        case MainMenu::ID_TOOL_OR:
            canvas->SetCurrentTool(TYPE_OR);
            GetStatusBar()->SetStatusText("OR Gate tool selected");
            break;

        case MainMenu::ID_TOOL_NOT:
            canvas->SetCurrentTool(TYPE_NOT);
            GetStatusBar()->SetStatusText("NOT Gate tool selected");
            break;

        case MainMenu::ID_TOOL_XOR:
            canvas->SetCurrentTool(TYPE_XOR);
            GetStatusBar()->SetStatusText("XOR Gate tool selected");
            break;

        case MainMenu::ID_TOOL_NAND:
            canvas->SetCurrentTool(TYPE_NAND);
            GetStatusBar()->SetStatusText("NAND Gate tool selected");
            break;

        case MainMenu::ID_TOOL_NOR:
            canvas->SetCurrentTool(TYPE_NOR);
            GetStatusBar()->SetStatusText("NOR Gate tool selected");
            break;

        case MainMenu::ID_TOOL_INPUT:
            canvas->SetCurrentTool(TYPE_INPUT);
            GetStatusBar()->SetStatusText("Input Pin tool selected");
            break;

        case MainMenu::ID_TOOL_OUTPUT:
            canvas->SetCurrentTool(TYPE_OUTPUT);
            GetStatusBar()->SetStatusText("Output Pin tool selected");
            break;

        case MainMenu::ID_RENAME:
            if (canvas->GetSelectedElement()) {
                wxString newName = wxGetTextFromUser("Enter new name:", "Rename Element",
                    canvas->GetSelectedElement()->GetDisplayName(), this);
                if (!newName.empty()) {
                    canvas->RenameSelectedElement(newName);
                    propertiesPanel->UpdateProperties();
                }
            }
            break;

        case MainMenu::ID_DELETE_ALL:
            canvas->DeleteAll();
            GetStatusBar()->SetStatusText("All elements deleted");
            break;

        case MainMenu::ID_TRUTH_TABLE:
            canvas->ShowTruthTable();
            GetStatusBar()->SetStatusText("Truth table displayed");
            break;

        case wxID_ABOUT:
            wxMessageBox("Logisim-like Circuit Simulator\n\n"
                "A simple digital logic circuit simulator built with wxWidgets\n\n"
                "Features:\n"
                "- Basic logic gates (AND, OR, NOT, XOR, NAND, NOR)\n"
                "- Input and output pins\n"
                "- Wire connections\n"
                "- Real-time simulation\n"
                "- Grid alignment\n"
                "- Zoom functionality\n"
                "- Property editing\n"
                "- File save/load functionality\n"
                "- Truth table generation\n"
                "- Delete all elements functionality",
                "About", wxOK | wxICON_INFORMATION, this);
            break;

        case wxID_HELP:
            wxMessageBox("Help Documentation\n\n"
                "1. Select a tool from the toolbar or Tools menu\n"
                "2. Click on the canvas to place components\n"
                "3. Use the Wire tool to connect components\n"
                "4. Right-click to select components\n"
                "5. Press Delete to delete selected components\n"
                "6. Use Simulation menu to start/stop simulation\n"
                "7. Use View menu to toggle grid display and zoom\n"
                "8. Use Properties panel to edit component properties\n"
                "9. Use Truth Table to see circuit logic\n"
                "10. Use Delete All to remove all elements\n\n"
                "Keyboard Shortcuts:\n"
                "A - AND Gate\n"
                "O - OR Gate\n"
                "N - NOT Gate\n"
                "X - XOR Gate\n"
                "I - Input Pin\n"
                "P - Output Pin\n"
                "W - Wire Tool\n"
                "S - Selection Tool\n"
                "G - Toggle Grid\n"
                "T - Truth Table\n"
                "Delete - Delete selected component\n"
                "F2 - Rename selected element\n"
                "Ctrl++ - Zoom in\n"
                "Ctrl+- - Zoom out\n"
                "Ctrl+0 - Reset zoom",
                "Help", wxOK | wxICON_INFORMATION, this);
            break;
            // 在 OnMenuEvent 方法中添加
        case wxID_DELETE:
            canvas->DeleteSelectedElement();
            GetStatusBar()->SetStatusText("Selected element deleted");
            break;
        default:
            event.Skip();
            break;
        }
    }

    void OnToolEvent(wxCommandEvent& event) {
        int id = event.GetId();

        switch (id) {
        case MainToolbar::ID_SELECT:
            canvas->SetCurrentTool(TYPE_SELECT);
            GetStatusBar()->SetStatusText("Selection tool activated");
            break;

        case MainToolbar::ID_WIRE:
            canvas->SetCurrentTool(TYPE_WIRE);
            GetStatusBar()->SetStatusText("Wire tool selected - click on pins to connect");
            break;

        case MainToolbar::ID_AND:
            canvas->SetCurrentTool(TYPE_AND);
            GetStatusBar()->SetStatusText("AND Gate tool selected");
            break;

        case MainToolbar::ID_OR:
            canvas->SetCurrentTool(TYPE_OR);
            GetStatusBar()->SetStatusText("OR Gate tool selected");
            break;

        case MainToolbar::ID_NOT:
            canvas->SetCurrentTool(TYPE_NOT);
            GetStatusBar()->SetStatusText("NOT Gate tool selected");
            break;

        case MainToolbar::ID_XOR:
            canvas->SetCurrentTool(TYPE_XOR);
            GetStatusBar()->SetStatusText("XOR Gate tool selected");
            break;

        case MainToolbar::ID_NAND:
            canvas->SetCurrentTool(TYPE_NAND);
            GetStatusBar()->SetStatusText("NAND Gate tool selected");
            break;

        case MainToolbar::ID_NOR:
            canvas->SetCurrentTool(TYPE_NOR);
            GetStatusBar()->SetStatusText("NOR Gate tool selected");
            break;

        case MainToolbar::ID_INPUT:
            canvas->SetCurrentTool(TYPE_INPUT);
            GetStatusBar()->SetStatusText("Input Pin tool selected");
            break;

        case MainToolbar::ID_OUTPUT:
            canvas->SetCurrentTool(TYPE_OUTPUT);
            GetStatusBar()->SetStatusText("Output Pin tool selected");
            break;

        case MainToolbar::ID_START_SIM:
            canvas->StartSimulation();
            GetStatusBar()->SetStatusText("Simulation running");
            break;

        case MainToolbar::ID_STOP_SIM:
            canvas->StopSimulation();
            GetStatusBar()->SetStatusText("Simulation stopped");
            break;

        case MainToolbar::ID_STEP:
            canvas->UpdateCircuit();
            canvas->Refresh();
            GetStatusBar()->SetStatusText("Simulation step executed");
            break;

        case MainToolbar::ID_DELETE_ALL:
            canvas->DeleteAll();
            GetStatusBar()->SetStatusText("All elements deleted");
            break;

        case MainToolbar::ID_TRUTH_TABLE:
            canvas->ShowTruthTable();
            GetStatusBar()->SetStatusText("Truth table displayed");
            break;

        default:
            event.Skip();
            break;
        }

        propertiesPanel->UpdateProperties();
    }
    void ToggleElementTree() {
        treeVisible = !treeVisible;

        if (treeVisible) {
            // 显示树控件
            leftSplitter->SplitVertically(elementTree, canvas, 200);
            GetStatusBar()->SetStatusText("Element tree shown");
        }
        else {
            // 隐藏树控件
            leftSplitter->Unsplit(elementTree);
            GetStatusBar()->SetStatusText("Element tree hidden");
        }

        leftSplitter->Layout();
    }
    void OnSaveAs(wxCommandEvent& event) {
        wxFileDialog saveFileDialog(this, "Save Circuit File", "", "",
            "Circuit files (*.circ)|*.circ", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

        if (saveFileDialog.ShowModal() == wxID_CANCEL)
            return;

        currentFilename = saveFileDialog.GetPath();
        if (!currentFilename.Contains(".")) {
            currentFilename += ".circ";
        }

        if (canvas->SaveCircuit(currentFilename)) {
            wxFileName fn(currentFilename);
            SetTitle(wxString::Format("Logisim-like Circuit Simulator - %s", fn.GetFullName()));
            GetStatusBar()->SetStatusText("Circuit saved successfully");
        }
        else {
            wxMessageBox("Failed to save circuit file", "Error", wxOK | wxICON_ERROR, this);
        }
    }

    bool ConfirmSave() {
        // 在实际应用中，这里应该检查电路是否已修改
        return true;
    }

    void OnClose(wxCloseEvent& event) {
        if (ConfirmSave()) {
            if (wxMessageBox("Are you sure you want to exit?", "Confirm Exit",
                wxYES_NO | wxICON_QUESTION, this) == wxYES) {
                Destroy();
            }
            else {
                event.Veto();
            }
        }
    }
};


// 应用程序类保持不变...
class MyApp : public wxApp {
public:
    virtual bool OnInit() override {
        wxInitAllImageHandlers();
        MainFrame* frame = new MainFrame();
        frame->Show(true);
        return true;
    }
};

wxIMPLEMENT_APP(MyApp);
