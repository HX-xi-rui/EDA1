// 工具栏类
class MainToolbar : public wxToolBar {
public:
    MainToolbar(wxWindow* parent, CircuitCanvas* canvas) : wxToolBar(parent, wxID_ANY), canvas(canvas) {
        AddTool(wxID_NEW, "New", wxArtProvider::GetBitmap(wxART_NEW), "New Circuit");
        AddTool(wxID_OPEN, "Open", wxArtProvider::GetBitmap(wxART_FILE_OPEN), "Open Circuit");
        AddTool(wxID_SAVE, "Save", wxArtProvider::GetBitmap(wxART_FILE_SAVE), "Save Circuit");

        // 撤销/重做按钮
        AddTool(wxID_UNDO, "Undo", wxArtProvider::GetBitmap(wxART_UNDO), "Undo (Ctrl+Z)");
        AddTool(wxID_REDO, "Redo", wxArtProvider::GetBitmap(wxART_REDO), "Redo (Ctrl+Y)");

        AddTool(ID_SELECT, "Select", wxBitmap(wxT("mouse.png"), wxBITMAP_TYPE_PNG), "Select", wxITEM_RADIO);
        AddTool(ID_TOGGLE_VALUE, "Toggle Value", wxArtProvider::GetBitmap(wxART_TIP), "Toggle Value Tool", wxITEM_RADIO);
        AddTool(ID_WIRE, "Wire", wxArtProvider::GetBitmap(wxART_PLUS), "Wire Tool", wxITEM_RADIO);


        AddTool(ID_AND, "AND", wxBitmap(wxT("AND.png"), wxBITMAP_TYPE_PNG), "AND Gate", wxITEM_RADIO);
        AddTool(ID_OR, "OR", wxBitmap(wxT("OR.png"), wxBITMAP_TYPE_PNG), "OR Gate", wxITEM_RADIO);
        AddTool(ID_NOT, "NOT", wxBitmap(wxT("NOT.png"), wxBITMAP_TYPE_PNG), "NOT Gate", wxITEM_RADIO);
        AddTool(ID_XOR, "XOR", wxBitmap(wxT("XOR.png"), wxBITMAP_TYPE_PNG), "XOR Gate", wxITEM_RADIO);
        AddTool(ID_NAND, "NAND", wxBitmap(wxT("NAND.png"), wxBITMAP_TYPE_PNG), "NAND Gate", wxITEM_RADIO);
        AddTool(ID_NOR, "NOR", wxBitmap(wxT("NOR.png"), wxBITMAP_TYPE_PNG), "NOR Gate", wxITEM_RADIO);


        AddTool(ID_INPUT, "Input", wxBitmap(wxT("INPUT.png"), wxBITMAP_TYPE_PNG), "Input Pin", wxITEM_RADIO);
        AddTool(ID_OUTPUT, "Output", wxBitmap(wxT("OUTPUT.png"), wxBITMAP_TYPE_PNG), "Output Pin", wxITEM_RADIO);


        AddTool(ID_START_SIM, "Start", wxArtProvider::GetBitmap(wxART_GO_FORWARD), "Start Simulation");
        AddTool(ID_STOP_SIM, "Stop", wxArtProvider::GetBitmap(wxART_STOP), "Stop Simulation");
        AddTool(ID_TRUTH_TABLE, "Truth Table", wxArtProvider::GetBitmap(wxART_LIST_VIEW), "Show Truth Table");


        AddTool(ID_DELETE_ALL, "Delete All", wxArtProvider::GetBitmap(wxART_DELETE), "Delete All Elements");
        AddTool(wxID_DELETE, "Delete", wxArtProvider::GetBitmap(wxART_DELETE), "Delete Selected Element");
        Realize();
        ToggleTool(ID_SELECT, true);

        // 初始时禁用撤销/重做按钮（因为没有操作历史）
        EnableTool(wxID_UNDO, false);
        EnableTool(wxID_REDO, false);

        // 绑定事件
        Bind(wxEVT_TOOL, &MainToolbar::OnToolClicked, this);

        // 绑定更新UI事件来动态启用/禁用撤销重做按钮
        Bind(wxEVT_UPDATE_UI, &MainToolbar::OnUpdateUI, this, wxID_UNDO);
        Bind(wxEVT_UPDATE_UI, &MainToolbar::OnUpdateUI, this, wxID_REDO);
    }

    enum {
        ID_SELECT = MainMenu::ID_FIT_TO_WINDOW + 1,
        ID_TOGGLE_VALUE,
        ID_WIRE,
        ID_AND,
        ID_OR,
        ID_NOT,
        ID_XOR,
        ID_NAND,
        ID_NOR,
        ID_CLOCK,
        ID_TOOL_RS_FLIPFLOP,
        ID_D_FLIPFLOP,
        ID_JK_FLIPFLOP,
        ID_T_FLIPFLOP,
        ID_REGISTER,
        ID_INPUT,
        ID_OUTPUT,
        ID_START_SIM,
        ID_STOP_SIM,
        ID_STEP,
        ID_DELETE_ALL,
        ID_TRUTH_TABLE,
        ID_TOGGLE_TREE
    };

private:
    void OnToolClicked(wxCommandEvent& event) {
        int id = event.GetId();
        ElementType toolType = TYPE_SELECT;

        switch (id) {
        case ID_SELECT:
            toolType = TYPE_SELECT;
            break;
        case ID_TOGGLE_VALUE:
            toolType = TYPE_TOGGLE_VALUE;
            break;
        case ID_WIRE:
            toolType = TYPE_WIRE;
            break;
        case ID_AND:
            toolType = TYPE_AND;
            break;
        case ID_OR:
            toolType = TYPE_OR;
            break;
        case ID_NOT:
            toolType = TYPE_NOT;
            break;
        case ID_XOR:
            toolType = TYPE_XOR;
            break;
        case ID_NAND:
            toolType = TYPE_NAND;
            break;
        case ID_NOR:
            toolType = TYPE_NOR;
            break;
        case ID_CLOCK:
            toolType = TYPE_CLOCK;
            break;
        case ID_D_FLIPFLOP:
            toolType = TYPE_D_FLIPFLOP;
            break;
        case ID_JK_FLIPFLOP:
            toolType = TYPE_JK_FLIPFLOP;
            break;
        case ID_T_FLIPFLOP:
            toolType = TYPE_T_FLIPFLOP;
            break;
        case ID_REGISTER:
            toolType = TYPE_REGISTER;
            break;
        case ID_INPUT:
            toolType = TYPE_INPUT;
            break;
        case ID_OUTPUT:
            toolType = TYPE_OUTPUT;
            break;
        default:
            event.Skip();
            return;
        }
        // 设置自动放置模式
        if (toolType != TYPE_SELECT && toolType != TYPE_WIRE && toolType != TYPE_TOGGLE_VALUE) {
            canvas->SetAutoPlaceMode(toolType);
        }
        else {
            canvas->SetCurrentTool(toolType);
        }

        // 更新工具栏状态
        for (int toolId = ID_SELECT; toolId <= ID_OUTPUT; toolId++) {
            ToggleTool(toolId, toolId == id);
        }
    }

    // 更新UI事件处理函数 - 用于动态启用/禁用撤销重做按钮
    void OnUpdateUI(wxUpdateUIEvent& event) {
        int id = event.GetId();

        if (id == wxID_UNDO) {
            event.Enable(canvas->CanUndo());
        }
        else if (id == wxID_REDO) {
            event.Enable(canvas->CanRedo());
        }
        else {
            event.Skip();
        }
    }
    CircuitCanvas* canvas;
};
// 画布类 
class CircuitCanvas : public wxScrolledWindow {
public:
    // 构造函数
    CircuitCanvas(wxWindow* parent) : wxScrolledWindow(parent, wxID_ANY),
        currentTool(TYPE_SELECT), wiringMode(false), selectedElement(nullptr),
        startPin(nullptr), simulating(false), showGrid(true), zoomLevel(1.0),
        autoPlaceMode(false), autoPlaceType(TYPE_SELECT),
        virtualSize(2000, 2000), isRestoringState(false) {

        // 设置滚动条
        SetScrollRate(10, 10);  // 设置滚动步长
        SetVirtualSize(virtualSize);  // 设置虚拟大小

        // 设置双缓冲避免闪烁
        SetBackgroundStyle(wxBG_STYLE_PAINT);

        // 绑定各种事件处理函数
        Bind(wxEVT_PAINT, &CircuitCanvas::OnPaint, this);
        Bind(wxEVT_LEFT_DOWN, &CircuitCanvas::OnLeftDown, this);
        Bind(wxEVT_LEFT_UP, &CircuitCanvas::OnLeftUp, this);
        Bind(wxEVT_MOTION, &CircuitCanvas::OnMouseMove, this);
        Bind(wxEVT_RIGHT_DOWN, &CircuitCanvas::OnRightDown, this);
        Bind(wxEVT_MOUSEWHEEL, &CircuitCanvas::OnMouseWheel, this);
        Bind(wxEVT_KEY_DOWN, &CircuitCanvas::OnKeyDown, this);
        Bind(wxEVT_SIZE, &CircuitCanvas::OnSize, this);
        Bind(wxEVT_MENU, &CircuitCanvas::OnContextMenu, this);

        // 绑定滚动事件
        Bind(wxEVT_SCROLLWIN_THUMBTRACK, &CircuitCanvas::OnScroll, this);
        Bind(wxEVT_SCROLLWIN_THUMBRELEASE, &CircuitCanvas::OnScroll, this);

        SetFocus();  // 设置焦点以接收键盘事件
    }

    void NotifyStateChange() {
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
            wxFrame* frame = static_cast<wxFrame*>(topWindow);
            if (wxToolBar* toolBar = frame->GetToolBar()) {
                toolBar->EnableTool(wxID_UNDO, CanUndo());
                toolBar->EnableTool(wxID_REDO, CanRedo());
            }
        }
    }

    // 在指定位置创建元件，支持时序元件
    void CreateElementAtPosition(ElementType type, const wxPoint& pos) {
        std::unique_ptr<CircuitElement> newElement;

        // 根据元件类型创建相应的元件对象
        if (type >= TYPE_AND && type <= TYPE_NOR) {  // 逻辑门元件
            newElement = std::make_unique<Gate>(type, pos.x, pos.y);
        }
        else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {  // 输入输出元件
            newElement = std::make_unique<InputOutput>(type, pos.x, pos.y);
        }
        else if (type == TYPE_CLOCK) {  // 时钟元件
            newElement = std::make_unique<ClockElement>(pos.x, pos.y);
        }
        else if (type == TYPE_RS_FLIPFLOP) {  // RS触发器 - 新增
            newElement = std::make_unique<RSFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_D_FLIPFLOP) {  // D触发器
            newElement = std::make_unique<DFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_JK_FLIPFLOP) {  // JK触发器
            newElement = std::make_unique<JKFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_T_FLIPFLOP) {  // T触发器
            newElement = std::make_unique<TFlipFlop>(pos.x, pos.y);
        }
        else if (type == TYPE_REGISTER) {  // 寄存器
            newElement = std::make_unique<RegisterElement>(pos.x, pos.y);
        }

        // 如果成功创建元件，将其添加到元件列表
        if (newElement) {
            CircuitElement* elementPtr = newElement.get();
            elements.push_back(std::move(newElement));

            // 记录添加元件操作（用于撤销/重做）
            if (!isRestoringState) {
                wxString serializedData = SerializeElement(elementPtr);
                auto operation = std::make_unique<AddElementOperation>(serializedData);
                undoStack.push_back(std::move(operation));

                // 限制历史记录数量
                if (undoStack.size() > MAX_HISTORY) {
                    undoStack.erase(undoStack.begin());
                }

                redoStack.clear();
                UpdateUndoRedoStatus();
            }

            Refresh();  // 刷新显示
        }
    }

    // 设置自动放置模式
    void SetAutoPlaceMode(ElementType type) {
        autoPlaceMode = (type != TYPE_SELECT && type != TYPE_WIRE);  // 非选择和连线工具时启用
        autoPlaceType = type;  // 设置要自动放置的类型
        currentTool = type;    // 设置当前工具
        wiringMode = (type == TYPE_WIRE);  // 如果是连线工具则设置连线模式

        if (autoPlaceMode) {
            // 设置鼠标光标为十字准星
            SetCursor(wxCursor(wxCURSOR_CROSS));
            // 显示提示信息
            wxWindow* topWindow = wxGetTopLevelParent(this);
            if (topWindow) {
                wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
                if (statusBar) {
                    statusBar->SetStatusText("Click on canvas to place " + GetToolName(type));
                }
            }
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));  // 恢复正常光标
        }

        Refresh();  // 刷新显示
    }

    // 上下文菜单事件处理
    void OnContextMenu(wxCommandEvent& event) {
        switch (event.GetId()) {
        case wxID_DELETE:
            DeleteSelectedElement();  // 删除选中元件
            break;
        case wxID_PROPERTIES:
            // 属性菜单（暂未实现）
            break;
        default:
            break;
        }
    }

    // 设置当前工具
    void SetCurrentTool(ElementType tool) {
        currentTool = tool;
        wiringMode = (tool == TYPE_WIRE);  // 设置连线模式
        autoPlaceMode = false; // 重置自动放置模式

        if (!wiringMode) {
            startPin = nullptr;  // 清除连线起始引脚
        }

        // 设置合适的鼠标光标
        if (tool == TYPE_TOGGLE_VALUE) {
            SetCursor(wxCursor(wxCURSOR_HAND));  // 切换值工具使用手型光标
        }
        else {
            SetCursor(wxCursor(wxCURSOR_ARROW));  // 其他工具使用箭头光标
        }
        Refresh();  // 刷新显示
    }

    // 删除选中元件
    void DeleteSelectedElement() {
        if (!selectedElement || isRestoringState) return;

        // 显示确认对话框
        wxMessageDialog dialog(GetParent(),
            "Are you sure you want to delete the selected element?",
            "Confirm Delete",
            wxYES_NO | wxICON_QUESTION);

        if (dialog.ShowModal() == wxID_YES) {
            // 序列化元件数据用于撤销
            wxString serializedData = SerializeElement(selectedElement);

            // 找到要删除的元件
            std::unique_ptr<CircuitElement> elementToDelete;
            auto it = std::find_if(elements.begin(), elements.end(),
                [this](const std::unique_ptr<CircuitElement>& elem) {
                    return elem.get() == selectedElement;
                });

            if (it != elements.end()) {
                // 先断开所有引脚连接
                auto pins = selectedElement->GetPins();
                for (auto pin : pins) {
                    // 找到并删除连接到该引脚的所有导线
                    for (auto wireIt = wires.begin(); wireIt != wires.end(); ) {
                        if ((*wireIt)->GetStartPin() == pin || (*wireIt)->GetEndPin() == pin) {
                            // 记录导线删除操作（如果需要撤销）
                            wireIt = wires.erase(wireIt);
                        }
                        else {
                            ++wireIt;
                        }
                    }
                    // 清除引脚的连接
                    pin->SetConnectedWire(nullptr);
                }

                // 保存要删除的元件
                elementToDelete = std::move(*it);

                // 记录删除操作到撤销栈
                auto operation = std::make_unique<DeleteElementOperation>(
                    std::move(elementToDelete), serializedData);

                // 限制历史记录数量
                if (undoStack.size() >= MAX_HISTORY) {
                    undoStack.erase(undoStack.begin());
                }
                undoStack.push_back(std::move(operation));
                redoStack.clear();
                UpdateUndoRedoStatus();

                // 从元素列表中移除
                elements.erase(it);

                // 清除选中状态
                selectedElement = nullptr;

                // 更新电路状态
                UpdateCircuit();
                Refresh();

                // 更新状态栏
                wxWindow* topWindow = wxGetTopLevelParent(this);
                if (topWindow) {
                    wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
                    if (statusBar) {
                        statusBar->SetStatusText("Element deleted");
                    }
                }
            }
        }
    }

    // 开始仿真
    void StartSimulation() {
        simulating = true;
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 1);

        // 为所有输入元件随机设置初始值
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* io = dynamic_cast<InputOutput*>(element.get());
                if (io) {
                    io->SetValue(dis(gen) == 0);  // 随机设置0或1
                }
            }
        }
        UpdateCircuit();  // 更新电路状态
        Refresh();  // 刷新显示
    }

    // 获取元件列表
    const std::vector<std::unique_ptr<CircuitElement>>& GetElements() const {
        return elements;
    }

    // 获取导线列表
    const std::vector<std::unique_ptr<Wire>>& GetWires() const {
        return wires;
    }

    // 停止仿真
    void StopSimulation() {
        simulating = false;

        // 将所有输入元件的值设为0（false）
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                if (input) {
                    input->SetValue(false);  // 重置为0
                }
            }
        }

        // 更新电路状态以反映所有输入为0的情况
        UpdateCircuit();
        Refresh();  // 刷新显示
    }

    // 更新整个电路状态
    void UpdateCircuit() {
        // 多次迭代确保信号稳定传播
        for (int i = 0; i < 5; ++i) {
            // 先更新输入元件
            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    element->Update();
                }
            }

            // 更新导线传递信号
            for (auto& wire : wires) {
                wire->Update();
            }

            // 更新逻辑门元件
            for (auto& element : elements) {
                if (element->GetType() >= TYPE_AND && element->GetType() <= TYPE_NOR) {
                    element->Update();
                }
            }

            // 再次更新导线
            for (auto& wire : wires) {
                wire->Update();
            }

            // 更新输出元件
            for (auto& element : elements) {
                if (element->GetType() == TYPE_OUTPUT) {
                    element->Update();
                }
            }
        }
    }

    // 清空画布
    void Clear() {
        elements.clear();  // 清空元件
        wires.clear();     // 清空导线
        selectedElement = nullptr;  // 清除选中
        startPin = nullptr;         // 清除连线起始引脚
        autoPlaceMode = false;      // 关闭自动放置模式
        undoStack.clear();          // 清空撤销栈
        redoStack.clear();          // 清空重做栈
        Refresh();  // 刷新显示
    }

    // 保存电路图
    bool SaveCircuit(const wxString& filename) {
        wxFile file;
        if (file.Create(filename, true)) {
            wxString data;

            // 保存所有元件
            for (auto& element : elements) {
                element->Serialize(data);
                data += "\n";
            }

            // 保存所有导线 
            for (auto& wire : wires) {
                Pin* startPin = wire->GetStartPin();
                Pin* endPin = wire->GetEndPin();

                if (startPin && endPin) {
                    // 保存起始引脚和结束引脚的坐标
                    data += wxString::Format("WIRE,%d,%d,%d,%d\n",
                        startPin->GetX(), startPin->GetY(),
                        endPin->GetX(), endPin->GetY());
                }
            }

            file.Write(data);
            file.Close();
            return true;
        }
        return false;
    }

    // 加载电路图
    bool LoadCircuit(const wxString& filename) {
        wxFile file;
        if (file.Open(filename)) {
            wxString data;
            file.ReadAll(&data);
            file.Close();

            Clear();  // 清空当前画布

            // 第一遍：加载所有元件
            wxStringTokenizer lines(data, "\n");
            while (lines.HasMoreTokens()) {
                wxString line = lines.GetNextToken().Trim();
                if (line.empty()) continue;

                wxStringTokenizer tokens(line, ",");
                if (tokens.HasMoreTokens()) {
                    wxString firstToken = tokens.GetNextToken();

                    if (firstToken == "WIRE") {
                        // 导线在第二遍处理
                        continue;
                    }
                    else {
                        long typeVal;
                        if (firstToken.ToLong(&typeVal)) {
                            ElementType type = static_cast<ElementType>(typeVal);

                            // 根据类型创建相应的元件
                            if (type >= TYPE_AND && type <= TYPE_NOR) {
                                auto gate = std::make_unique<Gate>(type, 0, 0);
                                gate->Deserialize(line);
                                elements.push_back(std::move(gate));
                            }
                            else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
                                auto io = std::make_unique<InputOutput>(type, 0, 0);
                                io->Deserialize(line);
                                elements.push_back(std::move(io));
                            }
                        }
                    }
                }
            }

            // 第二遍：重建导线连接
            lines = wxStringTokenizer(data, "\n");
            while (lines.HasMoreTokens()) {
                wxString line = lines.GetNextToken().Trim();
                if (line.empty()) continue;

                wxStringTokenizer tokens(line, ",");
                if (tokens.HasMoreTokens()) {
                    wxString firstToken = tokens.GetNextToken();

                    if (firstToken == "WIRE") {
                        if (tokens.CountTokens() >= 4) {
                            long startX, startY, endX, endY;
                            tokens.GetNextToken().ToLong(&startX);
                            tokens.GetNextToken().ToLong(&startY);
                            tokens.GetNextToken().ToLong(&endX);
                            tokens.GetNextToken().ToLong(&endY);

                            // 通过坐标查找对应的引脚
                            Pin* startPin = FindPinByPosition(startX, startY);
                            Pin* endPin = FindPinByPosition(endX, endY);

                            if (startPin && endPin && startPin->IsInput() != endPin->IsInput()) {
                                // 确保连接方向正确：输出引脚 -> 输入引脚
                                if (!startPin->IsInput() && endPin->IsInput()) {
                                    wires.push_back(std::make_unique<Wire>(startPin, endPin));
                                }
                                else if (startPin->IsInput() && !endPin->IsInput()) {
                                    wires.push_back(std::make_unique<Wire>(endPin, startPin));
                                }
                            }
                        }
                    }
                }
            }

            UpdateCircuit();
            Refresh();
            return true;
        }
        return false;
    }

    // 切换网格显示
    void ToggleGrid() {
        showGrid = !showGrid;
        Refresh();  // 刷新显示
    }

    // 删除所有元件
    void DeleteAll() {
        if (wxMessageBox("Are you sure you want to delete all elements?", "Confirm Delete All",
            wxYES_NO | wxICON_QUESTION, GetParent()) == wxYES) {
            Clear();
        }
    }

    // 放大
    void ZoomIn() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel *= 1.2;  // 增加缩放级别
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 缩小
    void ZoomOut() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel /= 1.2;  // 减小缩放级别
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 重置缩放
    void ResetZoom() {
        wxPoint oldCenter = GetViewCenter();
        zoomLevel = 1.0;  // 恢复原始缩放
        UpdateScrollbars();
        CenterView(oldCenter);
        Refresh();  // 刷新显示
    }

    // 获取缩放级别
    double GetZoomLevel() const { return zoomLevel; }

    // 获取选中元件
    CircuitElement* GetSelectedElement() const { return selectedElement; }

    // 重命名选中元件
    void RenameSelectedElement(const wxString& newName) {
        if (selectedElement) {
            InputOutput* io = dynamic_cast<InputOutput*>(selectedElement);
            if (io) {
                io->SetName(newName);  // 设置新名称
                Refresh();  // 刷新显示
            }
        }
    }

    // 显示真值表
    void ShowTruthTable();

    // 获取所有输入引脚
    std::vector<InputOutput*> GetInputPins() const {
        std::vector<InputOutput*> inputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT) {
                inputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return inputs;
    }

    // 获取所有输出引脚
    std::vector<InputOutput*> GetOutputPins() const {
        std::vector<InputOutput*> outputs;
        for (auto& element : elements) {
            if (element->GetType() == TYPE_OUTPUT) {
                outputs.push_back(dynamic_cast<InputOutput*>(element.get()));
            }
        }
        return outputs;
    }

    // 公共撤销/重做接口
    bool CanUndo() const { return !undoStack.empty(); }
    bool CanRedo() const { return !redoStack.empty(); }

    void Undo() {
        if (!CanUndo() || isRestoringState) return;

        isRestoringState = true;

        // 执行撤销操作
        if (!undoStack.empty()) {
            auto& operation = undoStack.back();
            operation->Undo(this);

            // 移动到重做栈
            redoStack.push_back(std::move(operation));
            undoStack.pop_back();
        }

        isRestoringState = false;
        UpdateUndoRedoStatus();
        Refresh();
        NotifyStateChange(); // 新增：通知状态改变

        // 更新状态栏
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow) {
            wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
            if (statusBar) {
                statusBar->SetStatusText("Undo performed");
            }
        }
    }

    void Redo() {
        if (!CanRedo() || isRestoringState) return;

        isRestoringState = true;

        // 执行重做操作
        if (!redoStack.empty()) {
            auto& operation = redoStack.back();
            operation->Execute(this);

            // 移动回撤销栈
            undoStack.push_back(std::move(operation));
            redoStack.pop_back();
        }

        isRestoringState = false;
        UpdateUndoRedoStatus();
        Refresh();
        NotifyStateChange(); // 新增：通知状态改变

        // 更新状态栏
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow) {
            wxStatusBar* statusBar = static_cast<wxFrame*>(topWindow)->GetStatusBar();
            if (statusBar) {
                statusBar->SetStatusText("Redo performed");
            }
        }
    }

    void ClearHistory() {
        undoStack.clear();
        redoStack.clear();
        UpdateUndoRedoStatus();
    }

    // 检查是否在自动放置模式
    bool IsInAutoPlaceMode() const { return autoPlaceMode; }
    // 获取自动放置类型
    ElementType GetAutoPlaceType() const { return autoPlaceType; }

private:
    // === 操作系统 ===
    enum OperationType {
        OP_ADD_ELEMENT,
        OP_DELETE_ELEMENT,
        OP_ADD_WIRE,
        OP_DELETE_WIRE,
        OP_MOVE_ELEMENT,
        OP_CHANGE_VALUE
    };

    // 操作基类，定义撤销/重做接口
    class Operation {
    public:
        Operation(OperationType type) : type(type) {}
        virtual ~Operation() {}
        virtual void Execute(CircuitCanvas* canvas) = 0;  // 执行操作
        virtual void Undo(CircuitCanvas* canvas) = 0;     // 撤销操作
        OperationType GetType() const { return type; }
    private:
        OperationType type;
    };

    // 添加元件操作
    class AddElementOperation : public Operation {
    public:
        AddElementOperation(const wxString& serializedData)
            : Operation(OP_ADD_ELEMENT), serializedData(serializedData) {
        }

        virtual void Execute(CircuitCanvas* canvas) override {
            canvas->RestoreElementFromSerializedData(serializedData);
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 找到并删除最后添加的元件（就是我们刚刚重做添加的那个）
            if (!canvas->elements.empty()) {
                CircuitElement* elementToRemove = canvas->elements.back().get();
                canvas->RemoveElementWithoutHistory(elementToRemove);
            }
        }

    private:
        wxString serializedData;
    };

    // 添加导线操作
    class AddWireOperation : public Operation {
    public:
        AddWireOperation(const wxString& serializedData)
            : Operation(OP_ADD_WIRE), serializedData(serializedData) {
        }

        virtual void Execute(CircuitCanvas* canvas) override {
            canvas->RestoreWireFromSerializedData(serializedData);
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 找到并删除最后添加的导线
            if (!canvas->wires.empty()) {
                Wire* wireToRemove = canvas->wires.back().get();
                canvas->RemoveWireWithoutHistory(wireToRemove);
            }
        }

    private:
        wxString serializedData;
    };

    // 删除元件操作
    class DeleteElementOperation : public Operation {
    public:
        DeleteElementOperation(std::unique_ptr<CircuitElement> element, const wxString& serializedData)
            : Operation(OP_DELETE_ELEMENT), element(std::move(element)), serializedData(serializedData) {
        }

        virtual void Execute(CircuitCanvas* canvas) override {
            // 重做删除操作：再次删除
            if (element) {
                canvas->RemoveElementWithoutHistory(element.get());
            }
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 撤销删除操作：恢复元件
            canvas->RestoreElementFromSerializedData(serializedData);
        }

    private:
        std::unique_ptr<CircuitElement> element;
        wxString serializedData;
    };

    // 删除导线操作
    class DeleteWireOperation : public Operation {
    public:
        DeleteWireOperation(std::unique_ptr<Wire> wire, const wxString& serializedData)
            : Operation(OP_DELETE_WIRE), wire(std::move(wire)), serializedData(serializedData) {
        }

        virtual void Execute(CircuitCanvas* canvas) override {
            // 重做删除操作：再次删除
            if (wire) {
                canvas->RemoveWireWithoutHistory(wire.get());
            }
        }

        virtual void Undo(CircuitCanvas* canvas) override {
            // 撤销删除操作：恢复导线
            canvas->RestoreWireFromSerializedData(serializedData);
        }

    private:
        std::unique_ptr<Wire> wire;
        wxString serializedData;
    };

    // === 撤销/重做系统 ===
    std::vector<std::unique_ptr<Operation>> undoStack;  // 撤销栈
    std::vector<std::unique_ptr<Operation>> redoStack;  // 重做栈
    const int MAX_HISTORY = 50;  // 最大历史记录数量
    bool isRestoringState;       // 是否正在恢复状态（防止递归记录操作）

    // === 序列化和反序列化方法 ===

    // 序列化元件
    wxString SerializeElement(CircuitElement* element) {
        wxString data;
        element->Serialize(data);
        return data;
    }

    // 序列化导线
    wxString SerializeWire(Wire* wire) {
        wxString data;
        wire->Serialize(data);
        return data;
    }

    // 从序列化数据恢复元件
    void RestoreElementFromSerializedData(const wxString& data) {
        CreateElementFromSerializedData(data);
        UpdateCircuit();
        Refresh();
    }

    // 从序列化数据恢复导线
    void RestoreWireFromSerializedData(const wxString& data) {
        CreateWireFromSerializedData(data);
        UpdateCircuit();
        Refresh();
    }

    // 无历史记录地删除元件（用于撤销/重做系统内部使用）
    void RemoveElementWithoutHistory(CircuitElement* element) {
        if (!element) return;

        isRestoringState = true;

        // 安全地删除与元件引脚相连的所有导线
        auto pins = element->GetPins();
        for (auto pin : pins) {
            // 使用临时向量收集要删除的导线，避免迭代器失效
            std::vector<Wire*> wiresToRemove;
            for (auto& wire : wires) {
                if (wire->GetStartPin() == pin || wire->GetEndPin() == pin) {
                    wiresToRemove.push_back(wire.get());
                }
            }

            // 删除收集到的导线
            for (auto wireToRemove : wiresToRemove) {
                auto it = std::find_if(wires.begin(), wires.end(),
                    [wireToRemove](const std::unique_ptr<Wire>& w) {
                        return w.get() == wireToRemove;
                    });
                if (it != wires.end()) {
                    wires.erase(it);
                }
            }

            // 清除引脚连接
            pin->SetConnectedWire(nullptr);
        }

        // 安全地删除元件
        auto it = std::find_if(elements.begin(), elements.end(),
            [element](const std::unique_ptr<CircuitElement>& elem) {
                return elem.get() == element;
            });

        if (it != elements.end()) {
            elements.erase(it);
        }

        // 清除选中状态
        if (selectedElement == element) {
            selectedElement = nullptr;
        }

        isRestoringState = false;
        UpdateCircuit();
        Refresh();
    }

    // 无历史记录地删除导线
    void RemoveWireWithoutHistory(Wire* wire) {
        isRestoringState = true;

        auto it = std::find_if(wires.begin(), wires.end(),
            [wire](const std::unique_ptr<Wire>& w) {
                return w.get() == wire;
            });

        if (it != wires.end()) {
            wires.erase(it);
        }

        isRestoringState = false;
        UpdateCircuit();
        Refresh();
    }

    // 完成导线连接
    void CompleteWireConnection(Pin* startPin, Pin* endPin) {
        if (startPin && endPin && startPin->IsInput() != endPin->IsInput()) {
            Pin* outputPin = startPin->IsInput() ? endPin : startPin;
            Pin* inputPin = startPin->IsInput() ? startPin : endPin;

            // 创建导线
            wires.push_back(std::make_unique<Wire>(outputPin, inputPin));
            Wire* wirePtr = wires.back().get();

            // 记录添加导线操作
            if (!isRestoringState) {
                wxString serializedData = SerializeWire(wirePtr);
                auto operation = std::make_unique<AddWireOperation>(serializedData);
                undoStack.push_back(std::move(operation));

                // 限制历史记录数量
                if (undoStack.size() > MAX_HISTORY) {
                    undoStack.erase(undoStack.begin());
                }

                redoStack.clear();
                UpdateUndoRedoStatus();
            }

            UpdateCircuit();
        }
        this->startPin = nullptr;
    }

    // === 原有的私有方法 ===

    // 从序列化数据创建元件
    void CreateElementFromSerializedData(const wxString& data) {
        wxStringTokenizer tokens(data, ",");
        if (tokens.CountTokens() >= 3) {
            long typeVal, x, y;
            tokens.GetNextToken().ToLong(&typeVal);
            tokens.GetNextToken().ToLong(&x);
            tokens.GetNextToken().ToLong(&y);

            ElementType type = static_cast<ElementType>(typeVal);
            std::unique_ptr<CircuitElement> newElement;

            // 根据类型创建相应的元件
            if (type >= TYPE_AND && type <= TYPE_NOR) {
                newElement = std::make_unique<Gate>(type, x, y);
            }
            else if (type == TYPE_INPUT || type == TYPE_OUTPUT) {
                newElement = std::make_unique<InputOutput>(type, x, y);

                // 处理输入输出的额外属性
                if (tokens.HasMoreTokens()) {
                    long value;
                    tokens.GetNextToken().ToLong(&value);
                    if (InputOutput* io = dynamic_cast<InputOutput*>(newElement.get())) {
                        io->SetValue(value != 0);
                    }
                    if (tokens.HasMoreTokens()) {
                        wxString name = tokens.GetNextToken();
                        if (InputOutput* io = dynamic_cast<InputOutput*>(newElement.get())) {
                            io->SetName(name);
                        }
                    }
                }
            }
            else if (type == TYPE_CLOCK) {
                newElement = std::make_unique<ClockElement>(x, y);
                if (tokens.HasMoreTokens()) {
                    long freq;
                    tokens.GetNextToken().ToLong(&freq);
                    if (ClockElement* clock = dynamic_cast<ClockElement*>(newElement.get())) {
                        clock->SetFrequency(freq);
                    }
                }
            }
            else if (type == TYPE_RS_FLIPFLOP) {  // 新增RS触发器
                newElement = std::make_unique<RSFlipFlop>(x, y);
            }
            else if (type == TYPE_D_FLIPFLOP) {
                newElement = std::make_unique<DFlipFlop>(x, y);
            }
            else if (type == TYPE_JK_FLIPFLOP) {
                newElement = std::make_unique<JKFlipFlop>(x, y);
            }
            else if (type == TYPE_T_FLIPFLOP) {
                newElement = std::make_unique<TFlipFlop>(x, y);
            }
            else if (type == TYPE_REGISTER) {
                newElement = std::make_unique<RegisterElement>(x, y);
            }

            if (newElement) {
                elements.push_back(std::move(newElement));
            }
        }
    }

    // 从序列化数据创建导线
    void CreateWireFromSerializedData(const wxString& data) {
        wxStringTokenizer tokens(data, ",");
        tokens.GetNextToken(); // 跳过 "WIRE"

        if (tokens.CountTokens() >= 6) {
            long startX, startY, startIsInput, endX, endY, endIsInput;
            tokens.GetNextToken().ToLong(&startX);
            tokens.GetNextToken().ToLong(&startY);
            tokens.GetNextToken().ToLong(&startIsInput);
            tokens.GetNextToken().ToLong(&endX);
            tokens.GetNextToken().ToLong(&endY);
            tokens.GetNextToken().ToLong(&endIsInput);

            // 通过坐标查找对应的引脚
            Pin* startPin = FindPinByPosition(startX, startY);
            Pin* endPin = FindPinByPosition(endX, endY);

            // 验证引脚类型匹配
            if (startPin && endPin &&
                startPin->IsInput() == (startIsInput == 1) &&
                endPin->IsInput() == (endIsInput == 1)) {

                // 确保连接方向正确：输出引脚 -> 输入引脚
                if (!startPin->IsInput() && endPin->IsInput()) {
                    wires.push_back(std::make_unique<Wire>(startPin, endPin));
                }
                else if (startPin->IsInput() && !endPin->IsInput()) {
                    wires.push_back(std::make_unique<Wire>(endPin, startPin));
                }
            }
        }
    }

    // 通过坐标查找引脚
    Pin* FindPinByPosition(int x, int y) {
        const int tolerance = 5;  // 容差范围
        for (auto& element : elements) {
            for (auto pin : element->GetPins()) {
                int pinX = pin->GetX();
                int pinY = pin->GetY();
                if (abs(pinX - x) <= tolerance && abs(pinY - y) <= tolerance) {
                    return pin;
                }
            }
        }
        return nullptr;
    }

    // 更新撤销/重做按钮状态
    void UpdateUndoRedoStatus() {
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
            wxFrame* frame = static_cast<wxFrame*>(topWindow);
            if (wxMenuBar* menuBar = frame->GetMenuBar()) {
                menuBar->Enable(wxID_UNDO, CanUndo());
                menuBar->Enable(wxID_REDO, CanRedo());
            }
            if (wxToolBar* toolBar = frame->GetToolBar()) {
                toolBar->EnableTool(wxID_UNDO, CanUndo());
                toolBar->EnableTool(wxID_REDO, CanRedo());
            }
        }
    }

    // 原有的私有成员变量
    ElementType currentTool;      // 当前工具类型
    bool wiringMode;              // 是否处于连线模式
    bool simulating;              // 是否正在仿真
    bool showGrid;                // 是否显示网格
    double zoomLevel;             // 缩放级别
    CircuitElement* selectedElement;  // 当前选中的元件
    Pin* startPin;                // 连线起始引脚
    wxPoint lastMousePos;         // 最后鼠标位置
    wxPoint dragStartPos;         // 拖动起始位置
    wxPoint elementStartPos;      // 元件起始位置
    bool autoPlaceMode;           // 自动放置模式
    ElementType autoPlaceType;    // 自动放置类型
    wxSize virtualSize;           // 虚拟画布大小
    std::vector<std::unique_ptr<CircuitElement>> elements;  // 元件列表
    std::vector<std::unique_ptr<Wire>> wires;               // 导线列表

    // 绘制事件处理
    void OnPaint(wxPaintEvent& event) {
        wxAutoBufferedPaintDC dc(this);  // 创建双缓冲绘图设备上下文
        DoPrepareDC(dc);  // 准备设备上下文，处理滚动和缩放

        dc.Clear();  // 清空画布

        dc.SetUserScale(zoomLevel, zoomLevel);  // 应用缩放

        // 获取可见区域（虚拟坐标）
        wxPoint viewStart = GetViewStart();
        wxSize clientSize = GetClientSize();

        // 正确的可见区域计算
        int startX = viewStart.x * 10;  // 转换为虚拟坐标
        int startY = viewStart.y * 10;
        int endX = startX + clientSize.x / zoomLevel;
        int endY = startY + clientSize.y / zoomLevel;

        // 绘制网格（只在可见区域绘制以提高性能）
        if (showGrid) {
            dc.SetPen(wxPen(wxColour(220, 220, 220), 1));

            // 计算网格起始位置（对齐到网格）
            int gridStartX = (startX / 20) * 20;
            int gridStartY = (startY / 20) * 20;

            // 绘制垂直线
            for (int x = gridStartX; x <= endX; x += 20) {
                dc.DrawLine(x, startY, x, endY);
            }
            // 绘制水平线
            for (int y = gridStartY; y <= endY; y += 20) {
                dc.DrawLine(startX, y, endX, y);
            }
        }

        // 绘制所有导线
        for (auto& wire : wires) {
            wire->Draw(dc);
        }

        // 绘制所有元件（只绘制在可见区域内的元件以提高性能）
        for (auto& element : elements) {
            wxRect bbox = element->GetBoundingBox();
            // 简单的可见性检查
            if (bbox.GetRight() >= startX && bbox.GetLeft() <= endX &&
                bbox.GetBottom() >= startY && bbox.GetTop() <= endY) {
                element->Draw(dc);
            }
        }

        // 为输入元件添加点击提示
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxFont smallFont = dc.GetFont();
            smallFont.SetPointSize(7);
            dc.SetFont(smallFont);

            for (auto& element : elements) {
                if (element->GetType() == TYPE_INPUT) {
                    InputOutput* input = dynamic_cast<InputOutput*>(element.get());
                    if (input) {
                        wxRect bbox = element->GetBoundingBox();
                        // 可见性检查
                        if (bbox.GetRight() >= startX && bbox.GetLeft() <= endX &&
                            bbox.GetBottom() >= startY && bbox.GetTop() <= endY) {
                            wxString hint = "(Click to toggle)";
                            wxSize textSize = dc.GetTextExtent(hint);
                            dc.DrawText(hint,
                                bbox.GetLeft() + (bbox.GetWidth() - textSize.GetWidth()) / 2,
                                bbox.GetBottom() + 5);
                        }
                    }
                }
            }
        }

        // 绘制连线过程中的临时线
        if (wiringMode && startPin) {
            dc.SetPen(wxPen(*wxBLUE, 2, wxPENSTYLE_DOT));
            dc.DrawLine(startPin->GetX(), startPin->GetY(), lastMousePos.x, lastMousePos.y);
        }

        // 绘制自动放置预览
        if (autoPlaceMode && !simulating) {
            DrawAutoPlacePreview(dc, lastMousePos);
        }

        dc.SetUserScale(1.0, 1.0);  // 恢复原始缩放

        // 绘制状态信息
        if (!simulating) {
            dc.SetTextForeground(*wxBLUE);
            wxString toolText = GetToolName(currentTool);
            if (autoPlaceMode) {
                toolText += " - Click to place";
            }
            dc.DrawText(toolText, 10, 10);

            // 显示当前视图位置和缩放信息
            wxString viewInfo = wxString::Format("View: (%d,%d) Zoom: %.0f%%", startX, startY, zoomLevel * 100);
            dc.DrawText(viewInfo, 10, 30);
        }
        else {
            dc.SetTextForeground(*wxRED);
            dc.DrawText("SIMULATION RUNNING", 10, 10);
        }
    }

    // 绘制自动放置预览
    void DrawAutoPlacePreview(wxDC& dc, const wxPoint& pos) {
        dc.SetPen(wxPen(*wxLIGHT_GREY, 1, wxPENSTYLE_DOT));  // 浅灰色虚线
        dc.SetBrush(*wxTRANSPARENT_BRUSH);  // 透明填充

        // 根据元件类型绘制预览轮廓
        switch (autoPlaceType) {
        case TYPE_AND:
        case TYPE_OR:
        case TYPE_NOT:
        case TYPE_XOR:
        case TYPE_NAND:
        case TYPE_NOR:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);  // 矩形轮廓
            break;
        case TYPE_INPUT:
        case TYPE_OUTPUT:
            dc.DrawRectangle(pos.x - 15, pos.y - 15, 30, 30);  // 矩形轮廓
            break;
        default:
            break;
        }
    }

    // 鼠标左键按下事件
    void OnLeftDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;  // 调整到缩放后坐标
        pos.y /= zoomLevel;
        lastMousePos = pos;  // 记录鼠标位置

        // 如果是显示真值工具模式，优先处理输入元件点击
        if (currentTool == TYPE_TOGGLE_VALUE) {
            if (TryToggleInputElement(pos)) {
                Refresh();
                return;
            }
        }

        if (autoPlaceMode) {
            // 自动放置模式：直接创建元件
            CreateElementAtPosition(autoPlaceType, pos);
            return;
        }

        if (currentTool == TYPE_SELECT || currentTool == TYPE_TOGGLE_VALUE) {
            selectedElement = nullptr;
            // 从后向前遍历（处理重叠元件）
            for (auto it = elements.rbegin(); it != elements.rend(); ++it) {
                if ((*it)->GetBoundingBox().Contains(pos)) {
                    selectedElement = it->get();
                    (*it)->SetSelected(true);

                    // 只有在选择工具模式下才能拖动
                    if (currentTool == TYPE_SELECT) {
                        dragStartPos = pos;  // 记录拖动起始位置
                        elementStartPos = wxPoint((*it)->GetX(), (*it)->GetY());  // 记录元件起始位置
                    }
                    break;
                }
            }

            // 如果没有选中元件，清除所有选中状态
            if (selectedElement == nullptr) {
                for (auto& element : elements) {
                    element->SetSelected(false);
                }
            }
        }
        // 在 OnLeftDown 方法中找到这个部分：
        else if (wiringMode) {
            // 连线模式：处理引脚连接
            Pin* pin = FindPinAt(pos);
            if (pin) {
                if (startPin == nullptr) {
                    startPin = pin;  // 设置起始引脚
                }
                else if (pin != startPin) {
                    // 确保连接的是输入和输出引脚
                    if (startPin->IsInput() != pin->IsInput()) {
                        // 使用新的方法完成连线并记录操作
                        CompleteWireConnection(startPin, pin);
                    }
                    startPin = nullptr;  // 重置起始引脚
                }
            }
            else if (startPin != nullptr) {
                startPin = nullptr;  // 点击空白处重置起始引脚
            }
        }
        else {
            // 传统模式：点击创建元件
            CreateElementAtPosition(currentTool, pos);
        }

        Refresh();  // 刷新显示
    }

    // 尝试切换输入元件的值
    bool TryToggleInputElement(const wxPoint& pos) {
        for (auto& element : elements) {
            if (element->GetType() == TYPE_INPUT && element->GetBoundingBox().Contains(pos)) {
                InputOutput* inputElement = dynamic_cast<InputOutput*>(element.get());
                if (inputElement) {
                    // 切换输入值（0变1，1变0）
                    inputElement->SetValue(!inputElement->GetValue());

                    // 更新电路状态
                    UpdateCircuit();

                    // 更新状态栏
                    wxWindow* topWindow = wxGetTopLevelParent(this);
                    if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
                        wxFrame* frame = static_cast<wxFrame*>(topWindow);
                        wxStatusBar* statusBar = frame->GetStatusBar();
                        if (statusBar) {
                            wxString state = inputElement->GetValue() ? "1" : "0";
                            wxString name = inputElement->GetDisplayName();
                            statusBar->SetStatusText(wxString::Format("%s toggled to %s", name, state));
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }

    // 鼠标左键释放事件
    void OnLeftUp(wxMouseEvent& event) {
        if (selectedElement) {
            selectedElement->SetSelected(false);  // 取消选中状态
        }
    }

    // 鼠标移动事件
    void OnMouseMove(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;
        pos.y /= zoomLevel;
        lastMousePos = pos;  // 记录鼠标位置

        // 只有在选择工具模式下才能拖动元件
        if (event.Dragging() && selectedElement && currentTool == TYPE_SELECT) {
            int gridSize = 20;  // 网格大小
            // 计算新位置
            int x = elementStartPos.x + (pos.x - dragStartPos.x);
            int y = elementStartPos.y + (pos.y - dragStartPos.y);

            // 对齐到网格
            x = (x / gridSize) * gridSize;
            y = (y / gridSize) * gridSize;

            selectedElement->SetPosition(x, y);  // 设置新位置
            Refresh();  // 刷新显示
        }

        // 连线模式下刷新临时线显示
        if (wiringMode && startPin) {
            Refresh();
        }

        // 在自动放置模式下实时刷新预览
        if (autoPlaceMode) {
            Refresh();
        }

        // 更新状态栏显示位置信息
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (topWindow && topWindow->IsKindOf(CLASSINFO(wxFrame))) {
            wxFrame* frame = static_cast<wxFrame*>(topWindow);
            wxStatusBar* statusBar = frame->GetStatusBar();
            if (statusBar) {
                int vx, vy;
                GetViewStart(&vx, &vy);
                wxString posInfo = wxString::Format("Position: (%d,%d)  View: (%d,%d)",
                    lastMousePos.x, lastMousePos.y, vx * 10, vy * 10);
                statusBar->SetStatusText(posInfo, 1);  // 在第二个字段显示
            }
        }
    }

    // 鼠标右键按下事件
    void OnRightDown(wxMouseEvent& event) {
        wxPoint pos = event.GetPosition();
        CalcUnscrolledPosition(pos.x, pos.y, &pos.x, &pos.y);  // 转换为虚拟坐标

        pos.x /= zoomLevel;
        pos.y /= zoomLevel;

        CircuitElement* clickedElement = nullptr;
        // 查找点击的元件
        for (auto& element : elements) {
            if (element->GetBoundingBox().Contains(pos)) {
                clickedElement = element.get();
                break;
            }
        }

        if (clickedElement) {
            // 设置选中元件
            if (selectedElement) {
                selectedElement->SetSelected(false);
            }
            selectedElement = clickedElement;
            selectedElement->SetSelected(true);

            // 创建上下文菜单
            wxMenu contextMenu;
            contextMenu.Append(wxID_DELETE, "Delete Element");
            contextMenu.Append(wxID_PROPERTIES, "Properties");

            PopupMenu(&contextMenu, event.GetPosition());  // 弹出菜单
            Refresh();  // 刷新显示
        }
        else {
            // 检查是否点击了导线
            for (auto& wire : wires) {
                if (wire->ContainsPoint(pos)) {
                    return;
                }
            }

            // 点击空白处清除选中
            if (selectedElement) {
                selectedElement->SetSelected(false);
                selectedElement = nullptr;
                Refresh();  // 刷新显示
            }
        }
    }

    // 鼠标滚轮事件
    void OnMouseWheel(wxMouseEvent& event) {
        if (event.ControlDown()) {
            // Ctrl+滚轮：缩放
            if (event.GetWheelRotation() > 0) {
                ZoomIn();
            }
            else {
                ZoomOut();
            }
        }
        else {
            // 普通滚轮：滚动
            event.Skip();  // 让父类处理滚动
        }
    }

    // 键盘按下事件
    void OnKeyDown(wxKeyEvent& event) {
        int vx, vy;
        GetViewStart(&vx, &vy);
        wxSize clientSize = GetClientSize();

        switch (event.GetKeyCode()) {
        case WXK_DELETE:
            DeleteSelectedElement();  // 删除选中元件
            break;
        case WXK_ESCAPE:
            if (autoPlaceMode) {
                // 退出自动放置模式
                autoPlaceMode = false;
                SetCursor(wxCursor(wxCURSOR_ARROW));
                Refresh();
            }
            else if (wiringMode && startPin) {
                startPin = nullptr;  // 取消连线
                Refresh();
            }
            break;
        case 'G':
            ToggleGrid();  // 切换网格显示
            break;
        case 'Z':
            if (event.ControlDown()) {
                if (event.ShiftDown()) {
                    Redo(); // Ctrl+Shift+Z 重做
                }
                else {
                    Undo(); // Ctrl+Z 撤销
                }
            }
            break;
        case 'Y':
            if (event.ControlDown()) {
                Redo(); // Ctrl+Y 重做
            }
            break;
            // 添加键盘滚动支持
        case WXK_LEFT:
            Scroll(vx - 1, vy);
            Refresh();
            break;
        case WXK_RIGHT:
            Scroll(vx + 1, vy);
            Refresh();
            break;
        case WXK_UP:
            Scroll(vx, vy - 1);
            Refresh();
            break;
        case WXK_DOWN:
            Scroll(vx, vy + 1);
            Refresh();
            break;
        case WXK_PAGEUP:
            Scroll(vx, vy - (clientSize.y / 20));
            Refresh();
            break;
        case WXK_PAGEDOWN:
            Scroll(vx, vy + (clientSize.y / 20));
            Refresh();
            break;
        case WXK_HOME:
            Scroll(0, 0);
            Refresh();
            break;
        case WXK_END:
            // 滚动到右下角（简化实现）
            Scroll(100, 100);
            Refresh();
            break;

        default:
            event.Skip();
            break;
        }
    }

    // 窗口大小改变事件
    void OnSize(wxSizeEvent& event) {
        Refresh();  // 刷新显示
        event.Skip();  // 传递事件
    }

    // 滚动事件处理
    void OnScroll(wxScrollWinEvent& event) {
        Refresh();  // 滚动时刷新显示
        event.Skip();  // 继续处理事件
    }

    // 在指定位置查找引脚
    Pin* FindPinAt(const wxPoint& pos) {
        for (auto& element : elements) {
            for (auto pin : element->GetPins()) {
                int dx = pin->GetX() - pos.x;
                int dy = pin->GetY() - pos.y;
                if (std::sqrt(dx * dx + dy * dy) < 5) {  // 5像素范围内
                    return pin;
                }
            }
        }
        return nullptr;  // 未找到引脚
    }

    // 获取工具名称
    wxString GetToolName(ElementType tool) {
        switch (tool) {
        case TYPE_SELECT: return "Selection Tool";
        case TYPE_TOGGLE_VALUE: return "Toggle Value Tool";
        case TYPE_AND: return "AND Gate";
        case TYPE_OR: return "OR Gate";
        case TYPE_NOT: return "NOT Gate";
        case TYPE_XOR: return "XOR Gate";
        case TYPE_NAND: return "NAND Gate";
        case TYPE_NOR: return "NOR Gate";
        case TYPE_INPUT: return "Input Pin";
        case TYPE_OUTPUT: return "Output Pin";
        case TYPE_WIRE: return "Wire Tool";
        default: return "Unknown Tool";
        }
    }

    // 获取当前视图中心
    wxPoint GetViewCenter() {
        int vx, vy;
        GetViewStart(&vx, &vy);
        wxSize clientSize = GetClientSize();
        return wxPoint(
            vx * 10 + clientSize.x / (2 * zoomLevel),
            vy * 10 + clientSize.y / (2 * zoomLevel)
        );
    }

    // 将视图中心设置为指定位置
    void CenterView(const wxPoint& center) {
        wxSize clientSize = GetClientSize();
        int newVX = (center.x - clientSize.x / (2 * zoomLevel)) / 10;
        int newVY = (center.y - clientSize.y / (2 * zoomLevel)) / 10;
        Scroll(newVX, newVY);
    }

    // 更新滚动条
    void UpdateScrollbars() {
        SetVirtualSize(
            virtualSize.x * zoomLevel,
            virtualSize.y * zoomLevel
        );
        SetScrollRate(20 * zoomLevel, 20 * zoomLevel);
    }

};
// 主窗口类
class MainFrame : public wxFrame {
public:
    // 构造函数
    MainFrame() : wxFrame(nullptr, wxID_ANY, "Logisim-like Circuit Simulator",
        wxDefaultPosition, wxSize(1200, 800)) {  // 设置窗口标题和初始大小

        // 创建主分割窗口
        mainSplitter = new wxSplitterWindow(this, wxID_ANY);

        // 创建左侧分割窗口（树控件和画布）
        leftSplitter = new wxSplitterWindow(mainSplitter, wxID_ANY);

        // 创建画布
        canvas = new CircuitCanvas(leftSplitter);

        // 创建元件树控件（现在传递正确的 canvas 引用）
        elementTree = new ElementTreeCtrl(leftSplitter, canvas);

        // 设置左侧分割窗口：垂直分割，树控件宽度200
        leftSplitter->SplitVertically(elementTree, canvas, 200);
        leftSplitter->SetMinimumPaneSize(100);  // 设置最小窗格大小

        // 创建属性面板
        propertiesPanel = new PropertiesPanel(mainSplitter, canvas);

        // 设置主分割窗口：垂直分割，左侧宽度800
        mainSplitter->SplitVertically(leftSplitter, propertiesPanel, 750);
        mainSplitter->SetMinimumPaneSize(200);  // 设置最小窗格大小

        // 创建菜单栏和工具栏
        menuBar = new MainMenu(canvas);
        SetMenuBar(menuBar);  // 设置菜单栏

        toolBar = new MainToolbar(this, canvas);
        SetToolBar(toolBar);  // 设置工具栏

        // 创建状态栏
        CreateStatusBar(2);  // 创建两个字段的状态栏
        GetStatusBar()->SetStatusText("Ready", 0);  // 设置初始状态文本
        GetStatusBar()->SetStatusText("", 1);       // 第二个字段用于显示位置信息

        // 绑定事件
        Bind(wxEVT_MENU, &MainFrame::OnMenuEvent, this);        // 菜单事件
        Bind(wxEVT_TOOL, &MainFrame::OnToolEvent, this);        // 工具栏事件
        Bind(wxEVT_CLOSE_WINDOW, &MainFrame::OnClose, this);    // 关闭事件

        // 设置最小大小
        SetMinClientSize(wxSize(800, 600));

        // 初始化属性面板
        propertiesPanel->UpdateProperties();

        // 初始化元件树
        elementTree->UpdateTree();
    }

private:
    // 私有成员变量
    MainMenu* menuBar;                    // 菜单栏指针
    MainToolbar* toolBar;                 // 工具栏指针
    CircuitCanvas* canvas;                // 电路画布指针
    PropertiesPanel* propertiesPanel;     // 属性面板指针
    wxSplitterWindow* mainSplitter;       // 主分割窗口指针
    wxSplitterWindow* leftSplitter;       // 左侧分割窗口指针
    ElementTreeCtrl* elementTree;         // 元件树控件指针
    wxString currentFilename;             // 当前文件名
    bool treeVisible = true;              // 树控件可见性标志

    // 菜单事件处理函数
    void OnMenuEvent(wxCommandEvent& event) {
        int id = event.GetId();  // 获取事件ID

        switch (id) {
        case wxID_UNDO:
            if (canvas->CanUndo()) {
                canvas->Undo();
                propertiesPanel->UpdateProperties();
                GetStatusBar()->SetStatusText("Undo performed");
            }
            break;

        case wxID_REDO:
            if (canvas->CanRedo()) {
                canvas->Redo();
                propertiesPanel->UpdateProperties();
                GetStatusBar()->SetStatusText("Redo performed");
            }
            break;
            // 切换值工具
        case MainMenu::ID_TOOL_TOGGLE_VALUE:
            canvas->SetCurrentTool(TYPE_TOGGLE_VALUE);
            GetStatusBar()->SetStatusText("Toggle Value tool selected - click on input pins to change values");
            break;

            // 切换树控件显示
        case ID_TOGGLE_TREE:
            ToggleElementTree();
            break;

            // 新建电路
        case wxID_NEW:
            if (ConfirmSave()) {
                canvas->Clear();  // 清空画布
                currentFilename = "";  // 重置文件名
                SetTitle("Logisim-like Circuit Simulator - New Circuit");  // 更新标题
                GetStatusBar()->SetStatusText("New circuit created");  // 更新状态栏
                propertiesPanel->UpdateProperties();  // 更新属性面板
            }
            break;

            // 打开电路文件
        case wxID_OPEN: {
            if (ConfirmSave()) {
                wxFileDialog openFileDialog(this, "Open Circuit File", "", "",
                    "Circuit files (*.circ)|*.circ", wxFD_OPEN | wxFD_FILE_MUST_EXIST);

                if (openFileDialog.ShowModal() == wxID_CANCEL)
                    return;

                currentFilename = openFileDialog.GetPath();  // 获取文件路径
                if (canvas->LoadCircuit(currentFilename)) {
                    wxFileName fn(currentFilename);
                    SetTitle(wxString::Format("Logisim-like Circuit Simulator - %s", fn.GetFullName()));  // 更新标题
                    GetStatusBar()->SetStatusText("Circuit loaded successfully");  // 更新状态栏
                    propertiesPanel->UpdateProperties();  // 更新属性面板
                }
                else {
                    wxMessageBox("Failed to load circuit file", "Error", wxOK | wxICON_ERROR, this);
                }
            }
            break;
        }

                      // 保存文件
        case wxID_SAVE:
            if (currentFilename.empty()) {
                OnSaveAs(event);  // 如果无文件名，调用另存为
            }
            else {
                if (canvas->SaveCircuit(currentFilename)) {
                    GetStatusBar()->SetStatusText("Circuit saved successfully");
                }
                else {
                    wxMessageBox("Failed to save circuit file", "Error", wxOK | wxICON_ERROR, this);
                }
            }
            break;

            // 另存为
        case wxID_SAVEAS:
            OnSaveAs(event);
            break;

            // 退出程序
        case wxID_EXIT:
            Close(true);
            break;

            // 开始仿真
        case MainMenu::ID_START_SIM:
            canvas->StartSimulation();
            GetStatusBar()->SetStatusText("Simulation running");
            break;

            // 停止仿真
        case MainMenu::ID_STOP_SIM:
            canvas->StopSimulation();
            GetStatusBar()->SetStatusText("Simulation stopped");
            break;

            // 单步仿真
        case MainMenu::ID_STEP:
            canvas->UpdateCircuit();
            canvas->Refresh();
            GetStatusBar()->SetStatusText("Simulation step executed");
            break;

            // 放大
        case MainMenu::ID_ZOOM_IN:
            canvas->ZoomIn();
            GetStatusBar()->SetStatusText(wxString::Format("Zoom: %.0f%%", canvas->GetZoomLevel() * 100));
            break;

            // 缩小
        case MainMenu::ID_ZOOM_OUT:
            canvas->ZoomOut();
            GetStatusBar()->SetStatusText(wxString::Format("Zoom: %.0f%%", canvas->GetZoomLevel() * 100));
            break;

            // 重置缩放
        case MainMenu::ID_ZOOM_RESET:
            canvas->ResetZoom();
            GetStatusBar()->SetStatusText("Zoom reset to 100%");
            break;

            // 切换网格显示
        case MainMenu::ID_TOGGLE_GRID:
            canvas->ToggleGrid();
            GetStatusBar()->SetStatusText("Grid toggled");
            break;

            // 居中视图
        case MainMenu::ID_CENTER_VIEW:
            canvas->Scroll(50, 50);
            GetStatusBar()->SetStatusText("View centered");
            break;

            // 适应窗口
        case MainMenu::ID_FIT_TO_WINDOW:
            canvas->ResetZoom();
            canvas->Scroll(0, 0);
            GetStatusBar()->SetStatusText("Circuit fitted to window");
            break;

            // 选择工具
        case MainMenu::ID_TOOL_SELECT:
            canvas->SetCurrentTool(TYPE_SELECT);
            GetStatusBar()->SetStatusText("Selection tool activated");
            break;

            // 连线工具
        case MainMenu::ID_TOOL_WIRE:
            canvas->SetCurrentTool(TYPE_WIRE);
            GetStatusBar()->SetStatusText("Wire tool selected - click on pins to connect");
            break;

            // AND门工具
        case MainMenu::ID_TOOL_AND:
            canvas->SetCurrentTool(TYPE_AND);
            GetStatusBar()->SetStatusText("AND Gate tool selected");
            break;

            // OR门工具
        case MainMenu::ID_TOOL_OR:
            canvas->SetCurrentTool(TYPE_OR);
            GetStatusBar()->SetStatusText("OR Gate tool selected");
            break;

            // NOT门工具
        case MainMenu::ID_TOOL_NOT:
            canvas->SetCurrentTool(TYPE_NOT);
            GetStatusBar()->SetStatusText("NOT Gate tool selected");
            break;

            // XOR门工具
        case MainMenu::ID_TOOL_XOR:
            canvas->SetCurrentTool(TYPE_XOR);
            GetStatusBar()->SetStatusText("XOR Gate tool selected");
            break;

            // NAND门工具
        case MainMenu::ID_TOOL_NAND:
            canvas->SetCurrentTool(TYPE_NAND);
            GetStatusBar()->SetStatusText("NAND Gate tool selected");
            break;

            // NOR门工具
        case MainMenu::ID_TOOL_NOR:
            canvas->SetCurrentTool(TYPE_NOR);
            GetStatusBar()->SetStatusText("NOR Gate tool selected");
            break;

            // 时钟工具
        case MainMenu::ID_TOOL_CLOCK:
            canvas->SetCurrentTool(TYPE_CLOCK);
            GetStatusBar()->SetStatusText("Clock tool selected");
            break;

            // RS触发器工具
        case MainMenu::ID_TOOL_RS_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_RS_FLIPFLOP);
            GetStatusBar()->SetStatusText("RS Flip-Flop tool selected");
            break;
            // D触发器工具
        case MainMenu::ID_TOOL_D_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_D_FLIPFLOP);
            GetStatusBar()->SetStatusText("D Flip-Flop tool selected");
            break;

            // JK触发器工具
        case MainMenu::ID_TOOL_JK_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_JK_FLIPFLOP);
            GetStatusBar()->SetStatusText("JK Flip-Flop tool selected");
            break;

            // T触发器工具
        case MainMenu::ID_TOOL_T_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_T_FLIPFLOP);
            GetStatusBar()->SetStatusText("T Flip-Flop tool selected");
            break;

            // 寄存器工具
        case MainMenu::ID_TOOL_REGISTER:
            canvas->SetCurrentTool(TYPE_REGISTER);
            GetStatusBar()->SetStatusText("Register tool selected");
            break;

            // 输入引脚工具
        case MainMenu::ID_TOOL_INPUT:
            canvas->SetCurrentTool(TYPE_INPUT);
            GetStatusBar()->SetStatusText("Input Pin tool selected");
            break;

            // 输出引脚工具
        case MainMenu::ID_TOOL_OUTPUT:
            canvas->SetCurrentTool(TYPE_OUTPUT);
            GetStatusBar()->SetStatusText("Output Pin tool selected");
            break;

            // 重命名元件
        case MainMenu::ID_RENAME:
            if (canvas->GetSelectedElement()) {
                wxString newName = wxGetTextFromUser("Enter new name:", "Rename Element",
                    canvas->GetSelectedElement()->GetDisplayName(), this);
                if (!newName.empty()) {
                    canvas->RenameSelectedElement(newName);
                    propertiesPanel->UpdateProperties();  // 更新属性面板
                }
            }
            break;

            // 删除所有元件
        case MainMenu::ID_DELETE_ALL:
            canvas->DeleteAll();
            GetStatusBar()->SetStatusText("All elements deleted");
            break;

            // 显示真值表
        case MainMenu::ID_TRUTH_TABLE:
            canvas->ShowTruthTable();
            GetStatusBar()->SetStatusText("Truth table displayed");
            break;

            // 关于对话框
        case wxID_ABOUT:
            wxMessageBox("Logisim-like Circuit Simulator\n\n"
                "A simple digital logic circuit simulator built with wxWidgets\n\n"
                "Features:\n"
                "- Basic logic gates (AND, OR, NOT, XOR, NAND, NOR)\n"
                "- Sequential elements (Flip-Flops, Registers, Clock)\n"
                "- Input and output pins\n"
                "- Wire connections\n"
                "- Real-time simulation\n"
                "- Grid alignment\n"
                "- Zoom and scroll functionality\n"
                "- Property editing\n"
                "- File save/load functionality\n"
                "- Truth table generation\n"
                "- Delete all elements functionality",
                "About", wxOK | wxICON_INFORMATION, this);
            break;

            // 帮助对话框
        case wxID_HELP:
            wxMessageBox("Help Documentation\n\n"
                "1. Select a tool from the toolbar or Tools menu\n"
                "2. Click on the canvas to place components\n"
                "3. Use the Wire tool to connect components\n"
                "4. Right-click to select components\n"
                "5. Press Delete to delete selected components\n"
                "6. Use Simulation menu to start/stop simulation\n"
                "7. Use View menu to toggle grid display, zoom and scroll\n"
                "8. Use Properties panel to edit component properties\n"
                "9. Use Truth Table to see circuit logic\n"
                "10. Use Delete All to remove all elements\n\n"
                "Keyboard Shortcuts:\n"
                "A - AND Gate\n"
                "O - OR Gate\n"
                "N - NOT Gate\n"
                "X - XOR Gate\n"
                "I - Input Pin\n"
                "P - Output Pin\n"
                "W - Wire Tool\n"
                "S - Selection Tool\n"
                "G - Toggle Grid\n"
                "T - Truth Table\n"
                "Delete - Delete selected component\n"
                "F2 - Rename selected element\n"
                "Ctrl++ - Zoom in\n"
                "Ctrl+- - Zoom out\n"
                "Ctrl+0 - Reset zoom\n"
                "Arrow Keys - Scroll view\n"
                "PageUp/PageDown - Fast scroll",
                "Help", wxOK | wxICON_INFORMATION, this);
            break;

            // 删除选中元件
        case wxID_DELETE:
            canvas->DeleteSelectedElement();
            GetStatusBar()->SetStatusText("Selected element deleted");
            break;

        default:
            event.Skip();  // 传递未处理的事件
            break;
        }
    }

    // 工具栏事件处理函数
    void OnToolEvent(wxCommandEvent& event) {
        int id = event.GetId();

        switch (id) {
        case wxID_UNDO:
            if (canvas->CanUndo()) {
                canvas->Undo();
                propertiesPanel->UpdateProperties();
                GetStatusBar()->SetStatusText("Undo performed");
            }
            break;

        case wxID_REDO:
            if (canvas->CanRedo()) {
                canvas->Redo();
                propertiesPanel->UpdateProperties();
                GetStatusBar()->SetStatusText("Redo performed");
            }
            break;
        case MainToolbar::ID_SELECT:
            canvas->SetCurrentTool(TYPE_SELECT);
            GetStatusBar()->SetStatusText("Selection tool activated");
            break;

        case MainToolbar::ID_WIRE:
            canvas->SetCurrentTool(TYPE_WIRE);
            GetStatusBar()->SetStatusText("Wire tool selected - click on pins to connect");
            break;

        case MainToolbar::ID_AND:
            canvas->SetCurrentTool(TYPE_AND);
            GetStatusBar()->SetStatusText("AND Gate tool selected");
            break;

        case MainToolbar::ID_OR:
            canvas->SetCurrentTool(TYPE_OR);
            GetStatusBar()->SetStatusText("OR Gate tool selected");
            break;

        case MainToolbar::ID_NOT:
            canvas->SetCurrentTool(TYPE_NOT);
            GetStatusBar()->SetStatusText("NOT Gate tool selected");
            break;

        case MainToolbar::ID_XOR:
            canvas->SetCurrentTool(TYPE_XOR);
            GetStatusBar()->SetStatusText("XOR Gate tool selected");
            break;

        case MainToolbar::ID_NAND:
            canvas->SetCurrentTool(TYPE_NAND);
            GetStatusBar()->SetStatusText("NAND Gate tool selected");
            break;

        case MainToolbar::ID_NOR:
            canvas->SetCurrentTool(TYPE_NOR);
            GetStatusBar()->SetStatusText("NOR Gate tool selected");
            break;

        case MainToolbar::ID_CLOCK:
            canvas->SetCurrentTool(TYPE_CLOCK);
            GetStatusBar()->SetStatusText("Clock tool selected");
            break;

        case MainToolbar::ID_D_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_D_FLIPFLOP);
            GetStatusBar()->SetStatusText("D Flip-Flop tool selected");
            break;

        case MainToolbar::ID_JK_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_JK_FLIPFLOP);
            GetStatusBar()->SetStatusText("JK Flip-Flop tool selected");
            break;

        case MainToolbar::ID_T_FLIPFLOP:
            canvas->SetCurrentTool(TYPE_T_FLIPFLOP);
            GetStatusBar()->SetStatusText("T Flip-Flop tool selected");
            break;

        case MainToolbar::ID_REGISTER:
            canvas->SetCurrentTool(TYPE_REGISTER);
            GetStatusBar()->SetStatusText("Register tool selected");
            break;

        case MainToolbar::ID_INPUT:
            canvas->SetCurrentTool(TYPE_INPUT);
            GetStatusBar()->SetStatusText("Input Pin tool selected");
            break;

        case MainToolbar::ID_OUTPUT:
            canvas->SetCurrentTool(TYPE_OUTPUT);
            GetStatusBar()->SetStatusText("Output Pin tool selected");
            break;

        case MainToolbar::ID_START_SIM:
            canvas->StartSimulation();
            GetStatusBar()->SetStatusText("Simulation running");
            break;

        case MainToolbar::ID_STOP_SIM:
            canvas->StopSimulation();
            GetStatusBar()->SetStatusText("Simulation stopped");
            break;

        case MainToolbar::ID_STEP:
            canvas->UpdateCircuit();
            canvas->Refresh();
            GetStatusBar()->SetStatusText("Simulation step executed");
            break;

        case MainToolbar::ID_DELETE_ALL:
            canvas->DeleteAll();
            GetStatusBar()->SetStatusText("All elements deleted");
            break;

        case MainToolbar::ID_TRUTH_TABLE:
            canvas->ShowTruthTable();
            GetStatusBar()->SetStatusText("Truth table displayed");
            break;

        default:
            event.Skip();  // 传递未处理的事件
            break;
        }
        toolBar->EnableTool(wxID_UNDO, canvas->CanUndo());
        toolBar->EnableTool(wxID_REDO, canvas->CanRedo());
        propertiesPanel->UpdateProperties();  // 更新属性面板
    }



    // 切换元件树显示状态
    void ToggleElementTree() {
        treeVisible = !treeVisible;  // 切换可见性标志

        if (treeVisible) {
            // 显示树控件
            leftSplitter->SplitVertically(elementTree, canvas, 200);
            GetStatusBar()->SetStatusText("Element tree shown");
        }
        else {
            // 隐藏树控件
            leftSplitter->Unsplit(elementTree);
            GetStatusBar()->SetStatusText("Element tree hidden");
        }

        leftSplitter->Layout();  // 重新布局
    }

    // 另存为处理函数
    void OnSaveAs(wxCommandEvent& event) {
        wxFileDialog saveFileDialog(this, "Save Circuit File", "", "",
            "Circuit files (*.circ)|*.circ", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);

        if (saveFileDialog.ShowModal() == wxID_CANCEL)
            return;

        currentFilename = saveFileDialog.GetPath();  // 获取文件路径
        if (!currentFilename.Contains(".")) {
            currentFilename += ".circ";  // 添加文件扩展名
        }

        if (canvas->SaveCircuit(currentFilename)) {
            wxFileName fn(currentFilename);
            SetTitle(wxString::Format("Logisim-like Circuit Simulator - %s", fn.GetFullName()));  // 更新标题
            GetStatusBar()->SetStatusText("Circuit saved successfully");  // 更新状态栏
        }
        else {
            wxMessageBox("Failed to save circuit file", "Error", wxOK | wxICON_ERROR, this);
        }
    }

    // 确认保存（简化实现）
    bool ConfirmSave() {
        // 在实际应用中，这里应该检查电路是否已修改
        return true;
    }

    // 关闭窗口事件处理
    void OnClose(wxCloseEvent& event) {

        if (wxMessageBox("Are you sure you want to exit?", "Confirm Exit",
            wxYES_NO | wxICON_QUESTION, this) == wxYES) {
            Destroy();  // 销毁窗口
        }
        else {
            event.Veto();  // 阻止关闭
        }
    }

};
