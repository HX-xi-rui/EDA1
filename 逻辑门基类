// 逻辑门基类
class Gate : public CircuitElement {
public:
    Gate(ElementType type, int x, int y) : CircuitElement(type, x, y) {
        // 根据门类型创建输入输出引脚
        if (type == TYPE_NOT) {
            inputs.push_back(std::make_unique<Pin>(x - 20, y, true, this));
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
        else {
            inputs.push_back(std::make_unique<Pin>(x - 20, y - 10, true, this));
            inputs.push_back(std::make_unique<Pin>(x - 20, y + 10, true, this));
            outputs.push_back(std::make_unique<Pin>(x + 20, y, false, this));
        }
    }

    virtual void Draw(wxDC& dc) override {
        dc.SetPen(selected ? wxPen(*wxRED, 2) : wxPen(*wxBLACK, 1));
        dc.SetBrush(*wxWHITE_BRUSH);

        switch (type) {
        case TYPE_AND:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("AND", posX - 12, posY - 7);
            break;
        case TYPE_OR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("OR", posX - 8, posY - 7);
            break;
        case TYPE_NOT:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("NOT", posX - 12, posY - 7);
            break;
        case TYPE_XOR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("XOR", posX - 12, posY - 7);
            break;
        case TYPE_NAND:
            dc.DrawRectangle(posX - 15, posY - 15, 30, 30);
            dc.DrawText("NAND", posX - 15, posY - 7);
            break;
        case TYPE_NOR:
            dc.DrawRoundedRectangle(posX - 15, posY - 15, 30, 30, 5);
            dc.DrawText("NOR", posX - 12, posY - 7);
            break;
        default:
            break;
        }

        // 绘制引脚
        dc.SetPen(*wxBLACK_PEN);
        for (auto& pin : inputs) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }
        for (auto& pin : outputs) {
            dc.DrawCircle(pin->GetX(), pin->GetY(), 3);
        }

        // 显示引脚值（在仿真时）
        if (wxWindow::FindWindowById(wxID_ANY)) {
            dc.SetTextForeground(*wxBLUE);
            wxFont smallFont = dc.GetFont();
            smallFont.SetPointSize(8);
            dc.SetFont(smallFont);

            for (auto& pin : inputs) {
                wxString val = pin->GetValue() ? "1" : "0";
                dc.DrawText(val, pin->GetX() - 8, pin->GetY() - 8);
            }
            for (auto& pin : outputs) {
                wxString val = pin->GetValue() ? "1" : "0";
                dc.DrawText(val, pin->GetX() + 5, pin->GetY() - 8);
            }
        }
    }

    virtual void Update() override {
        if (inputs.empty() || outputs.empty()) return;

        bool val0 = inputs[0]->GetConnectedWire() ? inputs[0]->GetValue() : false;
        bool val1 = inputs.size() > 1 && inputs[1]->GetConnectedWire() ? inputs[1]->GetValue() : false;

        bool result = false;

        switch (type) {
        case TYPE_AND:
            result = val0 && val1;
            break;
        case TYPE_OR:
            result = val0 || val1;
            break;
        case TYPE_NOT:
            result = !val0;
            break;
        case TYPE_XOR:
            result = val0 != val1;
            break;
        case TYPE_NAND:
            result = !(val0 && val1);
            break;
        case TYPE_NOR:
            result = !(val0 || val1);
            break;
        default:
            break;
        }

        outputs[0]->SetValue(result);
    }

    virtual std::vector<Pin*> GetPins() override {
        std::vector<Pin*> allPins;
        for (auto& pin : inputs) {
            allPins.push_back(pin.get());
        }
        for (auto& pin : outputs) {
            allPins.push_back(pin.get());
        }
        return allPins;
    }

    virtual wxRect GetBoundingBox() const override {
        return wxRect(posX - 20, posY - 20, 40, 40);
    }

    virtual wxString GetName() const override {
        switch (type) {
        case TYPE_AND: return "AND";
        case TYPE_OR: return "OR";
        case TYPE_NOT: return "NOT";
        case TYPE_XOR: return "XOR";
        case TYPE_NAND: return "NAND";
        case TYPE_NOR: return "NOR";
        default: return "Unknown";
        }
    }

    virtual wxString GetDisplayName() const override {
        return GetName() + " Gate";
    }

    virtual void Serialize(wxString& data) const override {
        data += wxString::Format("%d,%d,%d,", type, posX, posY);
    }

    virtual void Deserialize(const wxString& data) override {
        wxStringTokenizer tokenizer(data, ",");
        if (tokenizer.CountTokens() >= 3) {
            long typeVal, x, y;
            tokenizer.GetNextToken().ToLong(&typeVal);
            tokenizer.GetNextToken().ToLong(&x);
            tokenizer.GetNextToken().ToLong(&y);
            SetPosition(x, y);
        }
    }

    virtual void GetProperties(wxPropertyGrid* pg) const override {
        pg->Append(new wxStringProperty("Type", "Type", GetDisplayName()));
        pg->Append(new wxIntProperty("X Position", "X", posX));
        pg->Append(new wxIntProperty("Y Position", "Y", posY));
    }

    virtual void SetProperties(wxPropertyGrid* pg) override {
        wxVariant xVar = pg->GetPropertyValue("X");
        wxVariant yVar = pg->GetPropertyValue("Y");
        if (xVar.IsType("long") && yVar.IsType("long")) {
            SetPosition(xVar.GetLong(), yVar.GetLong());
        }
    }

private:
    std::vector<std::unique_ptr<Pin>> inputs;
    std::vector<std::unique_ptr<Pin>> outputs;
};
