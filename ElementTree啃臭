// 元件树控件类（AND门用24×24px自定义AND.png图标）
class ElementTreeCtrl : public wxTreeCtrl {
public:
    // 构造函数：接收父窗口和画布指针
    ElementTreeCtrl(wxWindow* parent, CircuitCanvas* canvas)
        : wxTreeCtrl(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize,
            wxTR_DEFAULT_STYLE | wxTR_HIDE_ROOT | wxTR_SINGLE),
        canvas(canvas), imageList(nullptr),
        // 初始化图标索引（-1表示无效）
        iconIndex_FileOpen(-1), iconIndex_GateOthers(-1),
        iconIndex_AND(-1), iconIndex_Clock(-1), iconIndex_IN(-1), iconIndex_OUT(-1),iconIndex_OR(-1), iconIndex_XOR(-1), iconIndex_NOR(-1), iconIndex_NOT(-1), iconIndex_NAND(-1)
    {
        // 1. 初始化图标列表（24×24px，适配自定义AND.png）
        InitImageList();
        // 2. 创建树节点结构（根节点+分类节点）
        CreateTreeStructure();
        // 3. 更新树内容（设置图标+添加节点）
        UpdateTree();
        // 4. 展开所有节点
        ExpandAll();
        // 5. 绑定事件
        BindEvents();
    }

    // 析构函数：释放图标列表内存
    ~ElementTreeCtrl() {
        if (imageList != nullptr) {
            delete imageList;
        }
    }

    // 更新树控件内容
    void UpdateTree() {
        // 清除现有子节点
        ClearAllChildNodes();

        // 图标索引有效时设置图标
        if (imageList != nullptr) {
            // 为分类节点设置图标
            SetCategoryNodeIcons();
            // 添加所有工具节点（AND门用自定义图标）
            AddAllToolNodes();
        }
        else {
            // 图标列表无效：仅添加无图标节点
            AddToolNodesWithoutIcon();
        }

        // 添加画布中已有的实际元件（AND门用自定义图标）和导线
        AddActualCircuitElements();
        AddActualCircuitWires();
    }

private:
    // 辅助函数1：初始化图标列表（核心：加载24×24px AND.png）
    void InitImageList() {
        // 图标尺寸改为24×24px（匹配自定义AND.png）
        imageList = new wxImageList(24, 24, true, 5); // 预留5个图标位置

        // -------------------------- 1. 加载自定义AND.png图标（24×24px） --------------------------
        wxString andImgPath = "AND.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_AND;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(andImgPath)) {
            bmp_AND.LoadFile(andImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_AND = imageList->Add(bmp_AND.IsOk() ? bmp_AND : CreateEmptyBitmap(24, 24));


        wxString nandImgPath = "NAND.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_NAND;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(nandImgPath)) {
            bmp_NAND.LoadFile(nandImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_NAND = imageList->Add(bmp_NAND.IsOk() ? bmp_NAND : CreateEmptyBitmap(24, 24));


        wxString orImgPath = "OR.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_OR;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(orImgPath)) {
            bmp_OR.LoadFile(orImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_OR = imageList->Add(bmp_OR.IsOk() ? bmp_OR : CreateEmptyBitmap(24, 24));

        wxString xorImgPath = "XOR.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_XOR;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(xorImgPath)) {
            bmp_XOR.LoadFile(xorImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_XOR = imageList->Add(bmp_XOR.IsOk() ? bmp_XOR : CreateEmptyBitmap(24, 24));


        wxString norImgPath = "NOR.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_NOR;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(norImgPath)) {
            bmp_NOR.LoadFile(norImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_NOR = imageList->Add(bmp_NOR.IsOk() ? bmp_NOR : CreateEmptyBitmap(24, 24));


        wxString notImgPath = "NOT.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_NOT;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(notImgPath)) {
            bmp_NOT.LoadFile(notImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_NOT = imageList->Add(bmp_NOT.IsOk() ? bmp_NOT : CreateEmptyBitmap(24, 24));


        wxString outImgPath = "OUTPUT.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_OUT;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(outImgPath)) {
            bmp_OUT.LoadFile(outImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_OUT = imageList->Add(bmp_OUT.IsOk() ? bmp_OUT : CreateEmptyBitmap(24, 24));


        wxString inImgPath = "INPUT.png"; // 图片路径（需与exe同目录，或写绝对路径）
        wxBitmap bmp_IN;
        // 检查图片文件是否存在
        if (wxFileName::FileExists(inImgPath)) {
            bmp_IN.LoadFile(inImgPath, wxBITMAP_TYPE_PNG);
        }
        // 加载失败时用备用图标
        iconIndex_IN = imageList->Add(bmp_IN.IsOk() ? bmp_IN : CreateEmptyBitmap(24, 24));

        // -------------------------- 2. 加载其他图标（24×24px，适配整体风格） --------------------------
        // 其他逻辑门（OR/NOT等）图标（用内置图标缩放）
        wxBitmap bmp_GateOthers = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_OTHER, wxSize(24, 24));
        iconIndex_GateOthers = imageList->Add(bmp_GateOthers.IsOk() ? bmp_GateOthers : CreateEmptyBitmap(24, 24));

        // 分类节点/工具默认图标
        wxBitmap bmp_FileOpen = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_OTHER, wxSize(24, 24));
        iconIndex_FileOpen = imageList->Add(bmp_FileOpen.IsOk() ? bmp_FileOpen : CreateEmptyBitmap(24, 24));

        // 时钟图标
        wxBitmap bmp_Clock = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_OTHER, wxSize(24, 24));
        iconIndex_Clock = imageList->Add(bmp_Clock.IsOk() ? bmp_Clock : CreateEmptyBitmap(24, 24));

        // 输入输出图标
        wxBitmap bmp_IO = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_OTHER, wxSize(24, 24));
        iconIndex_IO = imageList->Add(bmp_IO.IsOk() ? bmp_IO : CreateEmptyBitmap(24, 24));
        // 将图标列表绑定到树控件
        SetImageList(imageList);
    }

    // 辅助函数2：创建指定尺寸的空白图标（图标加载失败时备用）
    wxBitmap CreateEmptyBitmap(int width, int height) {
        wxBitmap bmp(width, height, 32); // 32位带透明通道
        wxMemoryDC dc(bmp);
        dc.SetBrush(*wxWHITE_BRUSH);
        dc.Clear(); // 填充白色背景（与树背景适配）
        return bmp;
    }

    // 辅助函数3：创建树的根节点和分类节点
    void CreateTreeStructure() {
        root = AddRoot("Circuit Elements"); // 根节点（隐藏）
        gatesNode = AppendItem(root, "Logic Gates"); // 逻辑门分类
        sequentialNode = AppendItem(root, "Sequential Elements"); // 时序元件分类
        ioNode = AppendItem(root, "Input/Output"); // 输入输出分类
        wiresNode = AppendItem(root, "Wire & Tools"); // 导线与工具分类
    }

    // 辅助函数4：绑定树控件事件
    void BindEvents() {
        Bind(wxEVT_TREE_SEL_CHANGED, &ElementTreeCtrl::OnSelectionChanged, this);
        Bind(wxEVT_TREE_ITEM_ACTIVATED, &ElementTreeCtrl::OnItemActivated, this);
    }

    // 辅助函数5：清除所有分类节点的子节点
    void ClearAllChildNodes() {
        DeleteChildren(gatesNode);
        DeleteChildren(sequentialNode);
        DeleteChildren(ioNode);
        DeleteChildren(wiresNode);
    }

    // 辅助函数6：为分类节点设置图标
    void SetCategoryNodeIcons() {
        // 逻辑门分类节点 → 其他逻辑门图标（非AND门）
        SetItemImage(gatesNode, iconIndex_GateOthers, wxTreeItemIcon_Normal);
        // 时序元件分类节点 → 时钟图标
        SetItemImage(sequentialNode, iconIndex_Clock, wxTreeItemIcon_Normal);
        // 输入输出分类节点 → 输入输出图标
        SetItemImage(ioNode, iconIndex_IN, wxTreeItemIcon_Normal);
        SetItemImage(ioNode, iconIndex_OUT, wxTreeItemIcon_Normal);
        SetItemImage(ioNode, iconIndex_IO, wxTreeItemIcon_Normal);
        // 导线与工具分类节点 → 默认图标
        SetItemImage(wiresNode, iconIndex_FileOpen, wxTreeItemIcon_Normal);
    }

    // 辅助函数7：添加所有工具节点（AND门用自定义AND.png）
    void AddAllToolNodes() {
        // -------------------------- AND门工具节点 → 自定义AND.png图标 --------------------------
        AddToolNode(gatesNode, "AND Gate", TYPE_AND, iconIndex_AND);

        // -------------------------- 其他逻辑门工具节点 → 通用门图标 --------------------------
        AddToolNode(gatesNode, "OR Gate", TYPE_OR, iconIndex_OR);
        AddToolNode(gatesNode, "NOT Gate", TYPE_NOT, iconIndex_NOT);
        AddToolNode(gatesNode, "XOR Gate", TYPE_XOR, iconIndex_XOR);
        AddToolNode(gatesNode, "NAND Gate", TYPE_NAND, iconIndex_NAND);
        AddToolNode(gatesNode, "NOR Gate", TYPE_NOR, iconIndex_NOR);

        // 时序元件工具节点 → 时钟图标
        AddToolNode(sequentialNode, "Clock (Hz Adjustable)", TYPE_CLOCK, iconIndex_Clock);
        AddToolNode(sequentialNode, "RS Flip-Flop", TYPE_RS_FLIPFLOP, iconIndex_Clock);
        AddToolNode(sequentialNode, "D Flip-Flop (Edge-Triggered)", TYPE_D_FLIPFLOP, iconIndex_Clock);
        AddToolNode(sequentialNode, "JK Flip-Flop", TYPE_JK_FLIPFLOP, iconIndex_Clock);
        AddToolNode(sequentialNode, "T Flip-Flop (Toggle)", TYPE_T_FLIPFLOP, iconIndex_Clock);
        AddToolNode(sequentialNode, "4-bit Register (Loadable)", TYPE_REGISTER, iconIndex_Clock);

        // 输入输出工具节点 → 输入输出图
        AddToolNode(ioNode, "Input Pin (Click to Toggle)", TYPE_INPUT, iconIndex_IN);
        AddToolNode(ioNode, "Output Pin (Status Display)", TYPE_OUTPUT, iconIndex_OUT);

        // 导线与工具节点 → 默认图标
        AddToolNode(wiresNode, "Wire Tool (Connect Pins)", TYPE_WIRE, iconIndex_FileOpen);
        AddToolNode(wiresNode, "Selection Tool (Move/Select)", TYPE_SELECT, iconIndex_FileOpen);
        AddToolNode(wiresNode, "Toggle Value Tool (Input)", TYPE_TOGGLE_VALUE, iconIndex_FileOpen);
    }

    // 辅助函数8：添加单个带图标工具节点（支持指定图标索引）
    void AddToolNode(wxTreeItemId parentNode, const wxString& nodeText, ElementType toolType, int iconIndex) {
        if (iconIndex == -1 || !parentNode.IsOk()) return;
        wxTreeItemId itemId = AppendItem(parentNode, nodeText);
        toolMap[itemId] = toolType;
        // 设置指定图标（24×24px）
        SetItemImage(itemId, iconIndex, wxTreeItemIcon_Normal);
    }

    // 辅助函数9：图标无效时添加无图标工具节点
    void AddToolNodesWithoutIcon() {
        AddToolNodeNoIcon(gatesNode, "AND Gate", TYPE_AND);
        AddToolNodeNoIcon(gatesNode, "OR Gate", TYPE_OR);
        AddToolNodeNoIcon(gatesNode, "NOT Gate", TYPE_NOT);
        AddToolNodeNoIcon(sequentialNode, "Clock", TYPE_CLOCK);
        AddToolNodeNoIcon(ioNode, "Input Pin", TYPE_INPUT);
        AddToolNodeNoIcon(ioNode, "Output Pin", TYPE_OUTPUT);
        AddToolNodeNoIcon(wiresNode, "Wire Tool", TYPE_WIRE);
        AddToolNodeNoIcon(wiresNode, "Selection Tool", TYPE_SELECT);
    }

    // 辅助函数10：添加单个无图标工具节点
    void AddToolNodeNoIcon(wxTreeItemId parentNode, const wxString& nodeText, ElementType toolType) {
        if (!parentNode.IsOk()) return;
        wxTreeItemId itemId = AppendItem(parentNode, nodeText);
        toolMap[itemId] = toolType;
    }

    // 辅助函数11：添加画布中已有的实际元件（AND门用自定义AND.png）
    void AddActualCircuitElements() {
        const std::vector<std::unique_ptr<CircuitElement>>& elements = canvas->GetElements();
        for (const auto& elem : elements) {
            wxTreeItemId parentNode = GetParentNodeByElementType(elem->GetType());
            if (!parentNode.IsOk()) continue;

            // 节点文字：显示名称+坐标
            wxString itemText = elem->GetDisplayName() +
                wxString::Format(" (X:%d, Y:%d)", elem->GetX(), elem->GetY());
            wxTreeItemId itemId = AppendItem(parentNode, itemText);
            elementMap[itemId] = elem.get();

            // -------------------------- 关键：AND门元件用自定义AND.png图标 --------------------------
            int targetIconIndex = -1;
            if (elem->GetType() == TYPE_AND) {
                targetIconIndex = iconIndex_AND; // AND门 → 自定义图标
            }
            if (elem->GetType() == TYPE_OR) {
                targetIconIndex = iconIndex_OR; // AND门 → 自定义图标
            }
            if (elem->GetType() == TYPE_XOR) {
                targetIconIndex = iconIndex_XOR; // AND门 → 自定义图标
            }
            if (elem->GetType() == TYPE_NAND) {
                targetIconIndex = iconIndex_NAND; // AND门 → 自定义图标
            }
            if (elem->GetType() == TYPE_NOR) {
                targetIconIndex = iconIndex_NOR; // AND门 → 自定义图标
            }
            if (elem->GetType() == TYPE_NOT) {
                targetIconIndex = iconIndex_NOT; // AND门 → 自定义图标
            }
            else if (IsLogicGateType(elem->GetType())) {
                targetIconIndex = iconIndex_GateOthers; // 其他逻辑门 → 通用图标
            }
            else if (IsSequentialType(elem->GetType())) {
                targetIconIndex = iconIndex_Clock; // 时序元件 → 时钟图标
            }
            else if (elem->GetType() == TYPE_INPUT ) {
                targetIconIndex = iconIndex_IN; // 输入输出 → IO图标
            }
            else if (elem->GetType() == TYPE_OUTPUT) {
                targetIconIndex = iconIndex_OUT; // 输入输出 → IO图标
            }
            else {
                targetIconIndex = iconIndex_FileOpen; // 默认图标
            }

            // 设置图标（24×24px）
            if (targetIconIndex != -1) {
                SetItemImage(itemId, targetIconIndex, wxTreeItemIcon_Normal);
            }
        }
    }

    // 辅助函数12：判断是否为逻辑门类型（除AND外）
    bool IsLogicGateType(ElementType type) {
        return type == TYPE_OR || type == TYPE_NOT || type == TYPE_XOR || type == TYPE_NAND || type == TYPE_NOR;
    }

    // 辅助函数13：判断是否为时序元件类型
    bool IsSequentialType(ElementType type) {
        return type == TYPE_CLOCK || type == TYPE_RS_FLIPFLOP || type == TYPE_D_FLIPFLOP ||
            type == TYPE_JK_FLIPFLOP || type == TYPE_T_FLIPFLOP || type == TYPE_REGISTER;
    }

    // 辅助函数14：添加画布中已有的实际导线节点
    void AddActualCircuitWires() {
        const std::vector<std::unique_ptr<Wire>>& wires = canvas->GetWires();
        for (size_t i = 0; i < wires.size(); ++i) {
            wxString wireText = wxString::Format("Wire %zu (Connected)", i + 1);
            wxTreeItemId itemId = AppendItem(wiresNode, wireText);
            wireMap[itemId] = wires[i].get();

            // 导线节点用默认图标
            if (iconIndex_FileOpen != -1) {
                SetItemImage(itemId, iconIndex_FileOpen, wxTreeItemIcon_Normal);
            }
        }
    }

    // 辅助函数15：根据元件类型获取对应的父分类节点
    wxTreeItemId GetParentNodeByElementType(ElementType type) {
        switch (type) {
        case TYPE_AND: case TYPE_OR: case TYPE_NOT: case TYPE_XOR: case TYPE_NAND: case TYPE_NOR:
            return gatesNode;
        case TYPE_CLOCK: case TYPE_RS_FLIPFLOP: case TYPE_D_FLIPFLOP: case TYPE_JK_FLIPFLOP: case TYPE_T_FLIPFLOP: case TYPE_REGISTER:
            return sequentialNode;
        case TYPE_INPUT: case TYPE_OUTPUT:
            return ioNode;
        default:
            return wxTreeItemId(); // 无效节点
        }
    }

    // 事件处理：树节点选择改变
    void OnSelectionChanged(wxTreeEvent& event) {
        wxTreeItemId selectedItem = event.GetItem();
        if (!selectedItem.IsOk()) return;

        // 检查是否为工具节点
        auto toolIt = toolMap.find(selectedItem);
        if (toolIt != toolMap.end()) {
            ElementType toolType = toolIt->second;
            canvas->SetCurrentTool(toolType);
            UpdateStatusBar(toolType); // 更新状态栏提示
        }
        event.Skip();
    }

    // 事件处理：树节点双击激活
    void OnItemActivated(wxTreeEvent& event) {
        wxTreeItemId activatedItem = event.GetItem();
        if (!activatedItem.IsOk()) return;

        // 检查是否为工具节点
        auto toolIt = toolMap.find(activatedItem);
        if (toolIt != toolMap.end()) {
            ElementType toolType = toolIt->second;
            // 排除选择工具和导线工具（不自动创建）
            if (toolType != TYPE_SELECT && toolType != TYPE_WIRE) {
                CreateElementAtCanvasCenter(toolType);
            }
            canvas->SetCurrentTool(toolType);
        }
        event.Skip();
    }

    // 辅助函数16：更新状态栏提示（通过顶层窗口）
    void UpdateStatusBar(ElementType toolType) {
        wxWindow* topWindow = wxGetTopLevelParent(this);
        if (!topWindow || !topWindow->IsKindOf(CLASSINFO(wxFrame))) return;

        wxFrame* frame = static_cast<wxFrame*>(topWindow);
        wxStatusBar* statusBar = frame->GetStatusBar();
        if (!statusBar) return;

        statusBar->SetStatusText(wxString::Format("Selected Tool: %s", GetToolDisplayName(toolType)));
    }

    // 辅助函数17：在画布中心创建元件
    void CreateElementAtCanvasCenter(ElementType toolType) {
        wxSize canvasSize = canvas->GetClientSize();
        wxPoint centerPos(canvasSize.GetWidth() / 2, canvasSize.GetHeight() / 2);
        canvas->CreateElementAtPosition(toolType, centerPos);
    }

    // 辅助函数18：获取工具的显示名称
    wxString GetToolDisplayName(ElementType toolType) {
        switch (toolType) {
        case TYPE_SELECT: return "Selection Tool (Move/Select Elements)";
        case TYPE_TOGGLE_VALUE: return "Toggle Value Tool (Click Input Pins)";
        case TYPE_WIRE: return "Wire Tool (Connect Pins)";
        case TYPE_AND: return "AND Gate (2-Input, Custom Icon)"; // 标注自定义图标
        case TYPE_OR: return "OR Gate (2-Input)";
        case TYPE_NOT: return "NOT Gate (1-Input)";
        case TYPE_XOR: return "XOR Gate (2-Input)";
        case TYPE_NAND: return "NAND Gate (2-Input)";
        case TYPE_NOR: return "NOR Gate (2-Input)";
        case TYPE_CLOCK: return "Clock Signal (Adjustable Frequency)";
        case TYPE_RS_FLIPFLOP: return "RS Flip-Flop (Set/Reset)";
        case TYPE_D_FLIPFLOP: return "D Flip-Flop (Edge-Triggered)";
        case TYPE_JK_FLIPFLOP: return "JK Flip-Flop (Set/Reset/Toggle)";
        case TYPE_T_FLIPFLOP: return "T Flip-Flop (Toggle Mode)";
        case TYPE_REGISTER: return "4-bit Register (Loadable)";
        case TYPE_INPUT: return "Input Pin (Click to Toggle Value)";
        case TYPE_OUTPUT: return "Output Pin (Display Signal Status)";
        default: return "Unknown Tool";
        }
    }

    // -------------------------- 私有成员变量 --------------------------
    wxImageList* imageList;                          // 24×24px图标列表
    // 图标索引（每个图标专属）
    int iconIndex_FileOpen;    // 默认图标（分类节点/导线工具）
    int iconIndex_GateOthers;  // 其他逻辑门（OR/NOT等）图标
    int iconIndex_AND;// AND门自定义图标（AND.png）
    int iconIndex_OR;
    int iconIndex_XOR;
    int iconIndex_NOR;
    int iconIndex_NOT;
    int iconIndex_NAND;
    int iconIndex_Clock;       // 时钟/时序元件图标
    int iconIndex_IN;
    int iconIndex_OUT;
	int iconIndex_IO;
    // 输入输出图标
    // 树节点
    wxTreeItemId root;                               // 根节点（隐藏）
    wxTreeItemId gatesNode;                          // 逻辑门分类节点
    wxTreeItemId sequentialNode;                     // 时序元件分类节点
    wxTreeItemId ioNode;                             // 输入输出分类节点
    wxTreeItemId wiresNode;                          // 导线与工具分类节点
    // 关联对象与映射
    CircuitCanvas* canvas;                           // 电路画布指针
    std::map<wxTreeItemId, ElementType> toolMap;     // 工具节点→元件类型映射
    std::map<wxTreeItemId, CircuitElement*> elementMap; // 节点→实际元件映射
    std::map<wxTreeItemId, Wire*> wireMap;           // 节点→实际导线映射
};
